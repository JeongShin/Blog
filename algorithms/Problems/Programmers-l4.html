<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>프로그래머스 Level04 | JS Blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="JeongShin 의 코딩 블로그 👨🏻‍💻">
    <meta name="google-site-verification" content="66JKoxw93huqhAdXO3P0K86NJZne5H-M3302YHcwoWI">
    <link rel="preload" href="/JeongShin_Blog/assets/css/0.styles.bfee8014.css" as="style"><link rel="preload" href="/JeongShin_Blog/assets/js/app.6288c20b.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/2.0d157e0d.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/7.b86e7d62.js" as="script"><link rel="prefetch" href="/JeongShin_Blog/assets/js/10.54d01932.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/11.18704fb4.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/12.ca2c8390.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/13.1c04bd7b.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/14.232f8e07.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/15.d6258687.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/16.aaea3afd.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/17.75b7e670.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/18.4a55a409.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/19.7fab6398.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/20.746595cb.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/21.cebbf420.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/22.29325e97.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/23.6e94e87b.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/24.55051895.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/25.afca3b9c.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/26.688061b5.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/27.cfdc89aa.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/28.4b3729b8.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/29.2c81d7cf.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/3.e31a6204.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/30.72bd2cd8.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/31.45b7a753.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/4.1a098c11.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/5.9a3b4a7a.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/6.cd3783a8.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/8.e3dbf8ea.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/9.4da5e707.js">
    <link rel="stylesheet" href="/JeongShin_Blog/assets/css/0.styles.bfee8014.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/JeongShin_Blog/" class="home-link router-link-active"><img src="/JeongShin_Blog/images/logo.jpg" alt="JS Blog" class="logo"> <span class="site-name can-hide">JS Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/JeongShin_Blog/guide/" class="sidebar-link">Guide</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/TIL/" class="sidebar-heading clickable"><span>Today I Learned</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/algorithms/" class="sidebar-heading clickable router-link-active open"><span>Algorithms</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/JeongShin_Blog/algorithms/Problems/" aria-current="page" class="sidebar-link">이론 정리</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Codility.html" class="sidebar-link">코딜리티</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l2.html" class="sidebar-link">프로그래머스 Level02</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l3.html" class="sidebar-link">프로그래머스 Level03</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html" aria-current="page" class="active sidebar-link">프로그래머스 Level04</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html#가사검색-trie-tree" class="sidebar-link">가사검색 - Trie, Tree</a></li><li class="sidebar-sub-header"><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html#징검다리-binary-search" class="sidebar-link">징검다리 - Binary Search</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/book-review/" class="sidebar-heading clickable"><span>Book-Review</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/daily/" class="sidebar-heading clickable"><span>Daily</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="프로그래머스-level04"><a href="#프로그래머스-level04" class="header-anchor">#</a> 프로그래머스 Level04</h1> <h2 id="가사검색-trie-tree"><a href="#가사검색-trie-tree" class="header-anchor">#</a> 가사검색 - Trie, Tree</h2> <p><a href="https://programmers.co.kr/learn/courses/30/lessons/60060" target="_blank" rel="noopener noreferrer">문제 링크<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://github.com/DKU-STUDY/Algorithm/blob/master/programmers/%EB%82%9C%EC%9D%B4%EB%8F%84%EB%B3%84/level04.%EA%B0%80%EC%82%AC_%EA%B2%80%EC%83%89/JeongShin.js" target="_blank" rel="noopener noreferrer">나의 풀이<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-문제정의"><a href="#_1-문제정의" class="header-anchor">#</a> 1. 문제정의</h3> <p>아래와 같은 word 배열 내에서 queries 조건에 일치하는 문자의 개수를 구하여 배열로 반환하는 문제</p> <div class="language- extra-class"><pre><code>words = [ frodo, front, frost, frozen, frame, kakao ]
queries = [ fro??, ????o, fr???, fro???, pro? ]

이때,
query 👉 일치하는 문자를 예로들면
fro?? 👉 frodo, front, frost
????o 👉 frodo, kakao
fr??? 👉 frodo, front, frost, frame
fro??? 👉 frozen
pro? 👉
</code></pre></div><p>와 같이 구할 수 있고 이에따라 [3, 2, 4, 1, 0] 을 반환해야 한다.</p> <h3 id="_2-풀이-코드"><a href="#_2-풀이-코드" class="header-anchor">#</a> 2. 풀이 &amp; 코드</h3> <h4 id="approach-1-linear-search"><a href="#approach-1-linear-search" class="header-anchor">#</a> Approach 1. Linear Search</h4> <p>가장 처음 접근한 솔루션은 Regular Expression 을 이용한 선형 탐색구조이다.</p> <p>이 접근 방법의 효율성을 따져보자.</p> <p>예를들어 n 개의 문자열 집합 중에서 특정 문자열의 포함 여부를 알아내는데 linear search를 하게 되면 특정 문자열의 길이가 m이라 하면,</p> <blockquote><p>Linear Search : O ( n*m )</p></blockquote> <p>정렬을 한뒤 binary seach 를 하게 되면,</p> <blockquote><p>Sorting &amp; Binary Seach : O ( n*m*log n )</p></blockquote> <p>의 시간이 든다.</p> <p>이때 문자열을 효율적으로 검색하는 <code>Trie</code> 자료구조를 사용하면</p> <blockquote><p>Trie : O ( m*log n )</p></blockquote> <p>의 가장 효율적인 방법이 된다.</p> <h4 id="approach-2-trie"><a href="#approach-2-trie" class="header-anchor">#</a> Approach 2. Trie</h4> <p>예를들어 아래와 같은 단어들이 있다고 가정하자</p> <div class="language- extra-class"><pre><code>words = [ coat, coffee, cat, car, chrome ]
</code></pre></div><p>이를 트라이로 만들면 아래와 같이 된다.</p> <p><img src="/JeongShin_Blog/assets/img/example.14b8c1f9.jpg" alt="example"></p> <p>따라서 가령 'co' 를 검색한다 하면 <strong>root 👉 c 👉 o 노드로 이동</strong>하여 결과로 'coffee' 와 'coat' 를 찾아낼 수 있다.</p> <p>이제 문제로 돌아가보자. 가장 먼저 노드는 아래와 같은 클래스로 정의해주었다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ⭐️ 자식 노드의 수</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>이때 count 는 자식의 수를 나타낸다. count 변수는 기본적인 Trie 구조에 직접 추가해준 변수인데,</p> <div class="language- extra-class"><pre><code>fro?? 👉 frodo, front, frost
</code></pre></div><p>우리의 목적은 fro?? 라는 문자열로 해당 3개의 문자를 찾아내야한다. 따라서 <strong>문자열의 자리수를 이용</strong>하면 조금 더 빠르게 검색할 수 있다.</p> <p>아래와 같이 문자열의 길이 length에 따라 서로 다른 trie를 만들어 준 뒤,</p> <p><img src="/JeongShin_Blog/assets/img/trie.8e4cbfa9.jpg" alt="trie"></p> <p>fro?? 의 경우 fro 까지 탐색을 한뒤 해당 노드의 count 를 반환해주면 된다.</p> <p>자 그럼 Trie 를 구현해보자. 필요한 함수는 트라이를 만드는 insert 함수, 문자열을 찾는 find 함수이다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">word<span class="token punctuation">,</span> target<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">!==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> curr <span class="token operator">=</span> word<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">?</span> idx<span class="token operator">++</span> <span class="token operator">:</span> idx<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>이 문제에 올 수 있는 queries 의 형태는 아래와 같다.</p> <div class="language- extra-class"><pre><code>1. fro?? 👉 ? 가 뒤에 오는 경우
2. ????o 👉 ? 가 앞에 오는 경우
3. ?????? 👉 ?만 오는 경우
</code></pre></div><p>2번 같은 경우 위와 같은 트라이 구조에서 검색이 불가능하다. 항상 search 는 문자열 앞에서 부터 또는 root 부터 하기 때문에 뒤에서 부터 <strong>거꾸로 검색</strong>하는 트라이가 필요하다.</p> <p>따라서 length 별로, forward 트라이 (type : true), backward 트라이 (type : false) 세 가지 조건을 고려하여 구현 하였다.</p> <p>이때 backward 트라이에 문자열을 insert 할때, 길이 n의 문자열을 뒤집는데 필요한 시간 복잡도는 O ( n ) 이 된다. 이 문제에서 주어지는 문자열은 상당히 길기 때문에 이 시간 또한 줄여주기 위해
split(), reverse(), join() 등의 함수를 이용하기보다 index와 length 를 이용하여 구현하였다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">find</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">word<span class="token punctuation">,</span> len <span class="token operator">=</span> word<span class="token punctuation">.</span>length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
    <span class="token keyword">let</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> curr <span class="token operator">=</span> word<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>
        idx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>find 함수의 경우 ? 를 제외한 문자열을 검색한 뒤 해당 노드의 count 를 반환하여 구현하였다.</p> <h3 id="_3-어려웠던-점"><a href="#_3-어려웠던-점" class="header-anchor">#</a> 3. 어려웠던 점</h3> <p>트라이라는 자료구조를 몰랐기 때문에 기본적인 트라이를 구현하고 문제를 풀이하는 순서로 진행하여 꽤 오랜시간이 걸렸다.</p> <p>하지만 문자열 관련된 문제는 나중에 언젠간 쓰일듯 하기 때문에 끝까지 풀이하여 성공,, 모든 테스트 케이스를 통과할땐, 짜릿하다 😖</p> <p>이런 문제가 코딩 테스트에 나오면 풀이할 자신은 없지만 언제나 <strong>어떻게든 한번 풀어보는게 중요</strong>한거 같다 (스터디 준일이형이 해준 말).</p> <h2 id="징검다리-binary-search"><a href="#징검다리-binary-search" class="header-anchor">#</a> 징검다리 - Binary Search</h2> <p><a href="https://programmers.co.kr/learn/courses/30/lessons/43236" target="_blank" rel="noopener noreferrer">문제링크<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://github.com/DKU-STUDY/Algorithm/blob/master/programmers/%EB%82%9C%EC%9D%B4%EB%8F%84%EB%B3%84/level04.%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC/JeongShin.js" target="_blank" rel="noopener noreferrer">나의풀이<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-문제정의-2"><a href="#_1-문제정의-2" class="header-anchor">#</a> 1. 문제정의</h3> <p>rocks 라는 바위의 위치를 나타내는 배열, distance 최대 거리, n 제거할 바위 수 세 개의 조건을 고려한다.</p> <div class="language- extra-class"><pre><code>바위는 0 부터 distance 사이에 rocks 배열에 나타난 위치에 바위가 놓여져 있다.
예를들어, rocks = [2, 11, 14, 17, 21], distance 는 25, n 은 2 라고 할때
두 개의 바위를 정하여 제거 해야한다. 이때 2, 14 가 제거되면 바위들의 위치는
[11, 17, 21]이 되고 사이 거리는 [11, 6, 4, 4]가 된다. 이때 거리의 최소 값 4를 구할 수 있다.
</code></pre></div><p>이때 n개의 바위를 제거하여 각 바위들 사이 거리가 최소가 되도록하여 최소 거리를 구하는 문제.</p> <h3 id="_2-풀이-코드-2"><a href="#_2-풀이-코드-2" class="header-anchor">#</a> 2. 풀이 &amp; 코드</h3> <p>바위 사이에 거리는 1 ~ distance 사이 범위내에 존재한다. 즉, 바위 간격이 아무리 멀어도 distance 보단 작고, 아무리 가까워도 1보단 크다.</p> <p>즉 우리가 구하려는 최소 거리 또한 1 ~ distance 사이 내에 존재한다. 이를 기반으로 이분탐색을 구현해보자.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">binSearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">[</span>left<span class="token punctuation">,</span> right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> distance<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mid <span class="token operator">=</span> <span class="token operator">~</span><span class="token operator">~</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// some codes</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* some condition */</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>일단 기본적인 이분탐색 뼈대에서 mid 값은 우리가 구하려는 최소 거리가 된다.</p> <p>따라서 some condition 에 오는 값은 <strong>최소 거리 mid 값이 n개의 바위 내에서 구해질 수 있는가</strong>가 되야 한다. 말이 어렵다. 아래 예제를 보자.</p> <div class="language- extra-class"><pre><code>Example 💁🏻‍♂️
| 0 | 2 | 11 | 14 | 17 | 21 | 25 | 에서
mid = 5, n = 2, removed = 0 (제거한 바위 수) 라고 가정하자.

0 👉 2 사이의 거리는 5보다 작기 때문에 제거. removed = 1
0 👉 11 사이의 거리 (2는 제거 되었기 때문에 고려 X) 는 5보다 크기 때문에 통과. removed = 1
11 👉 14 사이의 거리는 5보다 작기 때문에 제거. removed = 2
11 👉 17 사이의 거리는 (14는 제거 되었기 때문에 고려 X) 5보다 크기 때문에 통과.
17 👉 21 사이 거리는 5보다 작기 때문에 제거. removed = 3
이때 removed &gt; n 이 되기 때문에 해가 될 수 없음.

따라서 5 보다 더 작은 mid 값으로 이분탐색 진행
</code></pre></div><p>즉, some codes 에서 현재 mid 값으로 n개 이내의 범위 내에서 제거하여 해를 구할 수 있는가를 따져서 구현해주면 된다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">isPossible</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">min</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">[</span>removed<span class="token punctuation">,</span> prev<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> curr <span class="token keyword">of</span> rocks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1) 현재 바위와 이전 바위 사이 거리를 구함</span>
        <span class="token keyword">const</span> currDistance <span class="token operator">=</span> curr <span class="token operator">-</span> prev<span class="token punctuation">;</span>

    <span class="token comment">// 2) 거리가 최소 거리보다 짧을 경우 제거 대상이 됨</span>
        removed <span class="token operator">+=</span> currDistance <span class="token operator">&lt;</span> min<span class="token punctuation">;</span>

    <span class="token comment">// 3) 현재 바위가 제거 될 경우 현재 기준 prev를 그대로 전달</span>
        prev <span class="token operator">=</span> currDistance <span class="token operator">&lt;</span> min <span class="token operator">?</span> prev <span class="token operator">:</span> curr<span class="token punctuation">;</span>

    <span class="token comment">// 4) 제거한 바위 수가 n을 넘어가면 실패</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>removed <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>prev 바위를 설정하는게 다소 까다로운데</p> <ol><li>현재 바위 (curr) 가 제거 될 경우 현재 바위의 prev 가 그대로 다음 바위로 전달되어야 함</li> <li>현재 바위가 제거되지 않을 경우 prev 가 현재 바위로 설정 되어야 함</li></ol> <p>이 두 가지 경우를 잘 고려해주면 별 어려움 없이 해를 구할 수 있다.</p> <h3 id="_3-어려웠던-점-2"><a href="#_3-어려웠던-점-2" class="header-anchor">#</a> 3. 어려웠던 점</h3> <p>이 문제는 이분탐색이라는 문제 카테고리를 알고 있었지만 한번에 풀이에 접근하지 못했다.</p> <p>계속 linear search 를 해가면서 최소 거리 바위를 구하고 삭제하고 다음 최소 거리 바위를 구하고의 방법으로 접근하였다. 시간복잡도도 N * 제거할 바위 수 가 될 뿐더러 정확도에서도 제대로 된 결과를 얻지 못했다.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JeongShin_Blog/algorithms/Problems/Programmers-l3.html" class="prev">
        프로그래머스 Level03
      </a></span> <span class="next"><a href="/JeongShin_Blog/book-review/OOP_Principle/">
        스프링 입문을 위한 자바 향의 원리와 이해
      </a>
      →
    </span></p></div>  <div><div id="comment"></div></div></main> <footer class="siteFooter">
  COPYRIGHT©2020 ALL RIGHT JeongShin
  <br>sjeong1127@gmail.com . +82-10-2169-2142 .
  <br> <a href="https://www.instagram.com/jeongshin96/" target="_blank">Instagram</a> <a href="https://github.com/JeongShin" target="_blank">GitHub</a></footer></div><div class="global-ui"></div></div>
    <script src="/JeongShin_Blog/assets/js/app.6288c20b.js" defer></script><script src="/JeongShin_Blog/assets/js/2.0d157e0d.js" defer></script><script src="/JeongShin_Blog/assets/js/7.b86e7d62.js" defer></script>
  </body>
</html>
