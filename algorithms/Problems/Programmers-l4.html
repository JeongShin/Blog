<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>프로그래머스 Level04 | JS Blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="JeongShin 의 코딩 블로그 👨🏻‍💻">
    <meta name="google-site-verification" content="66JKoxw93huqhAdXO3P0K86NJZne5H-M3302YHcwoWI">
    <link rel="preload" href="/JeongShin_Blog/assets/css/0.styles.bfee8014.css" as="style"><link rel="preload" href="/JeongShin_Blog/assets/js/app.9dc32e83.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/2.0d157e0d.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/7.2cf3dd4b.js" as="script"><link rel="prefetch" href="/JeongShin_Blog/assets/js/10.54d01932.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/11.18704fb4.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/12.ca2c8390.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/13.1c04bd7b.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/14.596d1605.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/15.d6258687.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/16.aaea3afd.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/17.75b7e670.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/18.4a55a409.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/19.7fab6398.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/20.746595cb.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/21.cebbf420.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/22.29325e97.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/23.6e94e87b.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/24.55051895.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/25.a4650f8f.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/26.688061b5.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/27.cfdc89aa.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/28.4b3729b8.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/29.2c81d7cf.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/3.7eba4858.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/30.72bd2cd8.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/31.5ebb7971.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/4.1a098c11.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/5.9a3b4a7a.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/6.c013f770.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/8.e3dbf8ea.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/9.4da5e707.js">
    <link rel="stylesheet" href="/JeongShin_Blog/assets/css/0.styles.bfee8014.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/JeongShin_Blog/" class="home-link router-link-active"><img src="/JeongShin_Blog/images/logo.jpg" alt="JS Blog" class="logo"> <span class="site-name can-hide">JS Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/JeongShin_Blog/guide/" class="sidebar-link">Guide</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/TIL/" class="sidebar-heading clickable"><span>Today I Learned</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/algorithms/" class="sidebar-heading clickable router-link-active open"><span>Algorithms</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/JeongShin_Blog/algorithms/Problems/" aria-current="page" class="sidebar-link">이론 정리</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Codility.html" class="sidebar-link">코딜리티</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l2.html" class="sidebar-link">프로그래머스 Level02</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l3.html" class="sidebar-link">프로그래머스 Level03</a></li><li><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html" aria-current="page" class="active sidebar-link">프로그래머스 Level04</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html#가사검색-👉-trie" class="sidebar-link">가사검색 👉 Trie</a></li><li class="sidebar-sub-header"><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html#호텔-방-배정-👉-union-find" class="sidebar-link">호텔 방 배정 👉 Union-Find</a></li><li class="sidebar-sub-header"><a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html#징검다리-👉-binary-search" class="sidebar-link">징검다리 👉 Binary Search</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/book-review/" class="sidebar-heading clickable"><span>Book-Review</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/daily/" class="sidebar-heading clickable"><span>Daily</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="프로그래머스-level04"><a href="#프로그래머스-level04" class="header-anchor">#</a> 프로그래머스 Level04</h1> <h2 id="가사검색-👉-trie"><a href="#가사검색-👉-trie" class="header-anchor">#</a> 가사검색 👉 Trie</h2> <p><a href="https://programmers.co.kr/learn/courses/30/lessons/60060" target="_blank" rel="noopener noreferrer">문제 링크<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://github.com/DKU-STUDY/Algorithm/blob/master/programmers/%EB%82%9C%EC%9D%B4%EB%8F%84%EB%B3%84/level04.%EA%B0%80%EC%82%AC_%EA%B2%80%EC%83%89/JeongShin.js" target="_blank" rel="noopener noreferrer">나의 풀이<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-문제정의"><a href="#_1-문제정의" class="header-anchor">#</a> 1. 문제정의</h3> <p>아래와 같은 word 배열 내에서 queries 조건에 일치하는 문자의 개수를 구하여 배열로 반환하는 문제</p> <div class="language- extra-class"><pre><code>words = [ frodo, front, frost, frozen, frame, kakao ]
queries = [ fro??, ????o, fr???, fro???, pro? ]

이때,
query 👉 일치하는 문자를 예로들면
fro?? 👉 frodo, front, frost
????o 👉 frodo, kakao
fr??? 👉 frodo, front, frost, frame
fro??? 👉 frozen
pro? 👉
</code></pre></div><p>와 같이 구할 수 있고 이에따라 [3, 2, 4, 1, 0] 을 반환해야 한다.</p> <h3 id="_2-풀이-코드"><a href="#_2-풀이-코드" class="header-anchor">#</a> 2. 풀이 &amp; 코드</h3> <h4 id="approach-1-linear-search"><a href="#approach-1-linear-search" class="header-anchor">#</a> Approach 1. Linear Search</h4> <p>가장 처음 접근한 솔루션은 Regular Expression 을 이용한 선형 탐색구조이다.</p> <p>이 접근 방법의 효율성을 따져보자.</p> <p>예를들어 n 개의 문자열 집합 중에서 특정 문자열의 포함 여부를 알아내는데 linear search를 하게 되면 특정 문자열의 길이가 m이라 하면,</p> <blockquote><p>Linear Search : O ( n*m )</p></blockquote> <p>정렬을 한뒤 binary seach 를 하게 되면,</p> <blockquote><p>Sorting &amp; Binary Seach : O ( n*m*log n )</p></blockquote> <p>의 시간이 든다.</p> <p>이때 문자열을 효율적으로 검색하는 <code>Trie</code> 자료구조를 사용하면</p> <blockquote><p>Trie : O ( m*log n )</p></blockquote> <p>의 가장 효율적인 방법이 된다.</p> <h4 id="approach-2-trie"><a href="#approach-2-trie" class="header-anchor">#</a> Approach 2. Trie</h4> <p>예를들어 아래와 같은 단어들이 있다고 가정하자</p> <div class="language- extra-class"><pre><code>words = [ coat, coffee, cat, car, chrome ]
</code></pre></div><p>이를 트라이로 만들면 아래와 같이 된다.</p> <p><img src="/JeongShin_Blog/assets/img/example.14b8c1f9.jpg" alt="example"></p> <p>따라서 가령 'co' 를 검색한다 하면 <strong>root 👉 c 👉 o 노드로 이동</strong>하여 결과로 'coffee' 와 'coat' 를 찾아낼 수 있다.</p> <p>이제 문제로 돌아가보자. 가장 먼저 노드는 아래와 같은 클래스로 정의해주었다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ⭐️ 자식 노드의 수</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>이때 count 는 자식의 수를 나타낸다. count 변수는 기본적인 Trie 구조에 직접 추가해준 변수인데,</p> <div class="language- extra-class"><pre><code>fro?? 👉 frodo, front, frost
</code></pre></div><p>우리의 목적은 fro?? 라는 문자열로 해당 3개의 문자를 찾아내야한다. 따라서 <strong>문자열의 길이를 이용</strong>하면 조금 더 빠르게 검색할 수 있다.</p> <p>아래와 같이 문자열의 길이 length에 따라 서로 다른 trie를 만들어 준 뒤,</p> <p><img src="/JeongShin_Blog/assets/img/trie.8e4cbfa9.jpg" alt="trie"></p> <p>fro?? 의 경우 fro 까지 탐색을 한뒤 해당 노드의 count 를 반환해주면 된다.</p> <p>자 그럼 Trie 를 구현해보자. 필요한 함수는 트라이를 만드는 insert 함수, 문자열을 찾는 find 함수이다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">word<span class="token punctuation">,</span> target<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">!==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> curr <span class="token operator">=</span> word<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">?</span> idx<span class="token operator">++</span> <span class="token operator">:</span> idx<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>이 문제에 올 수 있는 queries 의 형태는 아래와 같다.</p> <div class="language- extra-class"><pre><code>1. fro?? 👉 ? 가 뒤에 오는 경우
2. ????o 👉 ? 가 앞에 오는 경우
3. ?????? 👉 ?만 오는 경우
</code></pre></div><p>2번 같은 경우 위와 같은 트라이 구조에서 검색이 불가능하다. 항상 search 는 문자열 앞에서 부터 또는 root 부터 하기 때문에 뒤에서 부터 <strong>거꾸로 검색</strong>하는 트라이가 필요하다.</p> <p>따라서 length 별로, forward 트라이 (type : true), backward 트라이 (type : false) 세 가지 조건을 고려하여 구현 하였다.</p> <p>이때 backward 트라이에 문자열을 insert 할때, 길이 n의 문자열을 뒤집는데 필요한 시간 복잡도는 O ( n ) 이 된다. 이 문제에서 주어지는 문자열은 상당히 길기 때문에 이 시간 또한 줄여주기 위해
split(), reverse(), join() 등의 함수를 이용하기보다 index와 length 를 이용하여 구현하였다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">find</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">word<span class="token punctuation">,</span> len <span class="token operator">=</span> word<span class="token punctuation">.</span>length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
    <span class="token keyword">let</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> curr <span class="token operator">=</span> word<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>
        idx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>find 함수의 경우 ? 를 제외한 문자열을 검색한 뒤 해당 노드의 count 를 반환하여 구현하였다.</p> <h3 id="_3-어려웠던-점"><a href="#_3-어려웠던-점" class="header-anchor">#</a> 3. 어려웠던 점</h3> <p>트라이라는 자료구조를 몰랐기 때문에 기본적인 트라이를 구현하고 문제를 풀이하는 순서로 진행하여 꽤 오랜시간이 걸렸다.</p> <p>하지만 문자열 관련된 문제는 나중에 언젠간 쓰일듯 하기 때문에 끝까지 풀이하여 성공,, 모든 테스트 케이스를 통과할땐, 짜릿하다 😖</p> <p>이런 문제가 코딩 테스트에 나오면 풀이할 자신은 없지만 언제나 <strong>어떻게든 한번 풀어보는게 중요</strong>한거 같다 (스터디 준일이형이 해준 말).</p> <h2 id="호텔-방-배정-👉-union-find"><a href="#호텔-방-배정-👉-union-find" class="header-anchor">#</a> 호텔 방 배정 👉 Union-Find</h2> <p><a href="https://programmers.co.kr/learn/courses/30/lessons/64063" target="_blank" rel="noopener noreferrer">문제링크<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="">나의풀이</a></p> <h3 id="_1-문제정의-2"><a href="#_1-문제정의-2" class="header-anchor">#</a> 1. 문제정의</h3> <p>호텔에서 투숙객에게 방을 배정하는데 아래와 같은 룰에 따라 방을 배정한다.</p> <div class="language- extra-class"><pre><code> 1. 한번에 한명씩 신청한 순서대로 방을 배정
 2. 고객은 원하는 방을 요청
 3. 고객이 원하는 방이 비어 있다면 즉시 방을 배정
 4. 고객이 원하는 방이 이미 배정 되어 있으면, 원하는 방보다 번호가 크면서
 비어 있는 방 중 번호가 가장 작은 방을 배정
</code></pre></div><p>만약 요청한 방이 다음과 같으면</p> <div class="language- extra-class"><pre><code>room_number = [ 1, 3, 4, 1, 3, 1 ]
1 👉 1번 방 즉시 배정
3 👉 3번 방 즉시 배정
4 👉 4번 방 즉시 배정
1 👉 1번 방은 이미 배정됨. 2번 방 배정
3 👉 3, 4번 방은 이미 배정됨. 5번 방 배정
1 👉 1,2,3,4,5번 방은 이미 배정됨. 6번 방 배정
</code></pre></div><p>즉, [ 1, 3, 4, 2, 5, 6 ] 을 리턴해야 한다.</p> <h3 id="_2-풀이-코드-2"><a href="#_2-풀이-코드-2" class="header-anchor">#</a> 2. 풀이 &amp; 코드</h3> <p>이 문제는 정확성과 효율성을 요구하는 문제이다.</p> <p>따라서 단순히 생각하면 모든 방마다 비어 있는 방을 linear search 하면 되지만 효율성을 고려하면 적합하지 않다.</p> <p><code>Union-find</code> 는 두개의 set 의 합집합을 찾을때 쓰이는 자료구조 이다.</p> <p>이 문제에서 union-find 가 동작하는 원리를 이용하여 풀이를 구현할 수 있는데 다음과 같다.</p> <div class="language- extra-class"><pre><code>만약 { 현재방 =&gt; 다음 배정 가능한 방 } 이라 가정할 때,
1번 방이 배정되면 { 1 =&gt; 2 } 가 된다.
2번 방이 배정되면 { 2 =&gt; 3 } 이 된다.
이때 만약 다시 1번 방 혹은 2번 방에 대한 요청이 들어올때
{ 1 =&gt; 3 , 2 =&gt; 3 } 과 같은 정보가 있다면 방을 즉시 배정 가능하다.
이때 1, 2번 방은 같은 부모(3번 방)를 가지는 하나의 집합이라 볼수 있다.
</code></pre></div><p>따라서 union-find 의 기법을 이용하여 요청이 들어온 방 별로 부모(배정 가능한 방)를 찾고
Map이란 자료구조에 해당 집합을 계속해서 업데이트 해주어 문제를 해결해보자.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> room <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ES6 Map 자료구조를 이용한다.</span>
<span class="token keyword">const</span> <span class="token function-variable function">findAndUnion</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 1. Find */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>room<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 부모를 찾지 못하면</span>
        room<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 부모를 n + 1 로 설정해준다.</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token comment">// 배정 가능한 방을 찾았으므로 리턴 해준다.</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 2. Union */</span>
    <span class="token keyword">let</span> parent <span class="token operator">=</span> <span class="token function">findAndUnion</span><span class="token punctuation">(</span>room<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 재귀적 호출로 최상위 부모를 찾아낸다.</span>
    room<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> parent <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 현재 방의 부모를 최상위 부모 + 1로 설정한다.</span>
    <span class="token keyword">return</span> parent<span class="token punctuation">;</span> <span class="token comment">// 최상위 부모 (이용 가능한 가장 작은 번호의 방)을 리턴한다.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>자 이제 동작 원리를 위의 예제를 통해 알아보자.</p> <div class="language- extra-class"><pre><code>1 👉 Map에 1은 없음 parent는 1
    Map { 1 =&gt; 2 }
3 👉 Map에 3은 없음 parent는 3
    Map { 1 =&gt; 2, 3 =&gt; 4 }
4 👉 Map에 4은 없음 parent는 4
    Map { 1 =&gt; 2, 3 =&gt; 4 , 4 =&gt; 5 }
1 👉 Map에 1이 존재 parent는 2
    Map { 1 =&gt; 3, 2 =&gt; 3, 3 =&gt; 4, 4 =&gt; 5 }
    이때 1 =&gt; 2 에서 1 =&gt; 3 으로 parent를 바꿔준다.
3 👉 Map에 3이 존재 3 =&gt; 4, 4도 존재 4 =&gt; 5 parent는 5
    Map { 1 =&gt; 3, 2 =&gt; 3, 3 =&gt; 6, 4 =&gt; 6, 5 =&gt; 6 }
    마찬가지로 3, 4, 5 거쳐온 경로 내에서 모든 부모를 최상위 부모 (5) + 1 인 6으로 바꿔준다.
</code></pre></div><p>즉, 가장 중요한 점은 비어있는 방을 탐색하면서 (Map에 없는 값을 탐색) 지나온 모든 경로에 해당되는 방의 부모를 최상위 부모 + 1 로 설정해주는게 중요하다.</p> <h3 id="_3-어려웠던-점-2"><a href="#_3-어려웠던-점-2" class="header-anchor">#</a> 3. 어려웠던 점</h3> <p>지나온 모든 경로에 대한 부모를 모두 같은 최상위 부모 + 1 로 설정해주는데 어려움을 겪었다.</p> <p>재귀호출은 언제나 코드를 보면 이해는 가지만 직접 구현하기 어렵다 ㅠ ㅠ 🤯</p> <h2 id="징검다리-👉-binary-search"><a href="#징검다리-👉-binary-search" class="header-anchor">#</a> 징검다리 👉 Binary Search</h2> <p><a href="https://programmers.co.kr/learn/courses/30/lessons/43236" target="_blank" rel="noopener noreferrer">문제링크<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://github.com/DKU-STUDY/Algorithm/blob/master/programmers/%EB%82%9C%EC%9D%B4%EB%8F%84%EB%B3%84/level04.%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC/JeongShin.js" target="_blank" rel="noopener noreferrer">나의풀이<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-문제정의-3"><a href="#_1-문제정의-3" class="header-anchor">#</a> 1. 문제정의</h3> <p>rocks 라는 바위의 위치를 나타내는 배열, distance 최대 거리, n 제거할 바위 수 세 개의 조건을 고려한다.</p> <div class="language- extra-class"><pre><code>바위는 0 부터 distance 사이에 rocks 배열에 나타난 위치에 바위가 놓여져 있다.
예를들어, rocks = [2, 11, 14, 17, 21], distance 는 25, n 은 2 라고 할때
두 개의 바위를 정하여 제거 해야한다. 이때 2, 14 가 제거되면 바위들의 위치는
[11, 17, 21]이 되고 사이 거리는 [11, 6, 4, 4]가 된다. 이때 거리의 최소 값 4를 구할 수 있다.
</code></pre></div><p>이때 n개의 바위를 제거하여 각 바위들 사이 거리가 최소가 되도록하여 최소 거리를 구하는 문제.</p> <h3 id="_2-풀이-코드-3"><a href="#_2-풀이-코드-3" class="header-anchor">#</a> 2. 풀이 &amp; 코드</h3> <p>바위 사이에 거리는 1 ~ distance 사이 범위내에 존재한다. 즉, 바위 간격이 아무리 멀어도 distance 보단 작고, 아무리 가까워도 1보단 크다.</p> <p>즉 우리가 구하려는 최소 거리 또한 1 ~ distance 사이 내에 존재한다. 이를 기반으로 이분탐색을 구현해보자.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">binSearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">[</span>left<span class="token punctuation">,</span> right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> distance<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mid <span class="token operator">=</span> <span class="token operator">~</span><span class="token operator">~</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// some codes</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* some condition */</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>일단 기본적인 이분탐색 뼈대에서 mid 값은 우리가 구하려는 최소 거리가 된다.</p> <p>따라서 some condition 에 오는 값은 <strong>최소 거리 mid 값이 n개의 바위 내에서 구해질 수 있는가</strong>가 되야 한다. 말이 어렵다. 아래 예제를 보자.</p> <div class="language- extra-class"><pre><code>Example 💁🏻‍♂️
| 0 | 2 | 11 | 14 | 17 | 21 | 25 | 에서
mid = 5, n = 2, removed = 0 (제거한 바위 수) 라고 가정하자.

0 👉 2 사이의 거리는 5보다 작기 때문에 제거. removed = 1
0 👉 11 사이의 거리 (2는 제거 되었기 때문에 고려 X) 는 5보다 크기 때문에 통과. removed = 1
11 👉 14 사이의 거리는 5보다 작기 때문에 제거. removed = 2
11 👉 17 사이의 거리는 (14는 제거 되었기 때문에 고려 X) 5보다 크기 때문에 통과.
17 👉 21 사이 거리는 5보다 작기 때문에 제거. removed = 3
이때 removed &gt; n 이 되기 때문에 해가 될 수 없음.

따라서 5 보다 더 작은 mid 값으로 이분탐색 진행
</code></pre></div><p>즉, some codes 에서 현재 mid 값으로 n개 이내의 범위 내에서 제거하여 해를 구할 수 있는가를 따져서 구현해주면 된다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">isPossible</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">min</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">[</span>removed<span class="token punctuation">,</span> prev<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> curr <span class="token keyword">of</span> rocks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1) 현재 바위와 이전 바위 사이 거리를 구함</span>
        <span class="token keyword">const</span> currDistance <span class="token operator">=</span> curr <span class="token operator">-</span> prev<span class="token punctuation">;</span>

    <span class="token comment">// 2) 거리가 최소 거리보다 짧을 경우 제거 대상이 됨</span>
        removed <span class="token operator">+=</span> currDistance <span class="token operator">&lt;</span> min<span class="token punctuation">;</span>

    <span class="token comment">// 3) 현재 바위가 제거 될 경우 현재 기준 prev를 그대로 전달</span>
        prev <span class="token operator">=</span> currDistance <span class="token operator">&lt;</span> min <span class="token operator">?</span> prev <span class="token operator">:</span> curr<span class="token punctuation">;</span>

    <span class="token comment">// 4) 제거한 바위 수가 n을 넘어가면 실패</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>removed <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>prev 바위를 설정하는게 다소 까다로운데</p> <ol><li>현재 바위 (curr) 가 제거 될 경우 현재 바위의 prev 가 그대로 다음 바위로 전달되어야 함</li> <li>현재 바위가 제거되지 않을 경우 prev 가 현재 바위로 설정 되어야 함</li></ol> <p>이 두 가지 경우를 잘 고려해주면 별 어려움 없이 해를 구할 수 있다.</p> <h3 id="_3-어려웠던-점-3"><a href="#_3-어려웠던-점-3" class="header-anchor">#</a> 3. 어려웠던 점</h3> <p>이 문제는 이분탐색이라는 문제 카테고리를 알고 있었지만 한번에 풀이에 접근하지 못했다.</p> <p>계속 linear search 를 해가면서 최소 거리 바위를 구하고 삭제하고 다음 최소 거리 바위를 구하고의 방법으로 접근하였다. 시간복잡도도 N * 제거할 바위 수 가 될 뿐더러 정확도에서도 제대로 된 결과를 얻지 못했다.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JeongShin_Blog/algorithms/Problems/Programmers-l3.html" class="prev">
        프로그래머스 Level03
      </a></span> <span class="next"><a href="/JeongShin_Blog/book-review/OOP_Principle/">
        자바 객체지향의 원리와 이해
      </a>
      →
    </span></p></div>  <div><div id="comment"></div></div></main> <footer class="siteFooter">
  COPYRIGHT©2020 ALL RIGHT JeongShin
  <br>sjeong1127@gmail.com . +82-10-2169-2142 .
  <br> <a href="https://www.instagram.com/jeongshin96/" target="_blank">Instagram</a> <a href="https://github.com/JeongShin" target="_blank">GitHub</a></footer></div><div class="global-ui"></div></div>
    <script src="/JeongShin_Blog/assets/js/app.9dc32e83.js" defer></script><script src="/JeongShin_Blog/assets/js/2.0d157e0d.js" defer></script><script src="/JeongShin_Blog/assets/js/7.2cf3dd4b.js" defer></script>
  </body>
</html>
