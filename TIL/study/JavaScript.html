<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 프론트엔드 스터디 | JS Blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="JeongShin 의 코딩 블로그 👨🏻‍💻">
    <link rel="preload" href="/JeongShin_Blog/assets/css/0.styles.29a1e9b9.css" as="style"><link rel="preload" href="/JeongShin_Blog/assets/js/app.02edf619.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/2.d8f9045d.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/9.e8039219.js" as="script"><link rel="prefetch" href="/JeongShin_Blog/assets/js/10.35267aa0.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/11.fdb2e051.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/12.1c0eaaa2.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/13.bdc1b9db.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/14.23a40e41.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/15.53bf8c9f.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/16.cd4d447a.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/17.0f923e47.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/18.0365a839.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/19.a8d00153.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/20.f7ab7ea0.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/21.0c77b20f.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/22.7d8e99e1.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/23.82277633.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/24.502bea40.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/25.d6714772.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/26.eb158c7a.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/3.c1b020e5.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/4.70352c87.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/5.9b7c23d1.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/6.c99465ab.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/7.f864a3cd.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/8.fb5b50a5.js">
    <link rel="stylesheet" href="/JeongShin_Blog/assets/css/0.styles.29a1e9b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/JeongShin_Blog/" class="home-link router-link-active"><img src="/JeongShin_Blog/images/logo.jpg" alt="JS Blog" class="logo"> <span class="site-name can-hide">JS Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/JeongShin_Blog/guide/" class="sidebar-link">Guide</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/TIL/" class="sidebar-heading clickable router-link-active open"><span>Today I Learned</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/JeongShin_Blog/TIL/study/" aria-current="page" class="sidebar-link">WEB 🌏</a></li><li><a href="/JeongShin_Blog/TIL/study/JavaScript.html" aria-current="page" class="active sidebar-link">JS 프론트엔드 스터디</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JeongShin_Blog/TIL/study/JavaScript.html#step-2" class="sidebar-link">Step 2</a></li><li class="sidebar-sub-header"><a href="/JeongShin_Blog/TIL/study/JavaScript.html#step-3" class="sidebar-link">Step 3</a></li></ul></li><li><a href="/JeongShin_Blog/TIL/study/NodeJS.html" class="sidebar-link">Node JS</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/algorithms/" class="sidebar-heading clickable"><span>Algorithms</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/book-review/" class="sidebar-heading clickable"><span>Book-Review</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/daily/" class="sidebar-heading clickable"><span>Daily</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-프론트엔드-스터디"><a href="#js-프론트엔드-스터디" class="header-anchor">#</a> JS 프론트엔드 스터디</h1> <h2 id="step-2"><a href="#step-2" class="header-anchor">#</a> Step 2</h2> <h3 id="전역객체-window"><a href="#전역객체-window" class="header-anchor">#</a> 전역객체 window</h3> <p>전역객체 <code>Global Object</code> 는 특수한 객체로 <strong>모든 객체는 전역 객체의 프로퍼티</strong>가 된다. 따라서 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다.</p> <p>전역객체의 이름은 호스트 환경에 따라 달라지는데 예를들어 웹 브라우저에서 전역객체는 <strong>window</strong> node.js 에서는 <strong>global</strong>이 된다. 전역 객체 API는 ECMAScript에 정의되어 있다.</p> <p>출처 : <a href="https://opentutorials.org/module/532/6577" target="_blank" rel="noopener noreferrer">생활코딩전역객체<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="원시타입과-참조타입"><a href="#원시타입과-참조타입" class="header-anchor">#</a> 원시타입과 참조타입</h3> <p>자바스크립트에는 다음 7가지 <code>Primitives</code> 원시 타입이 있다. (Object 제외) 이 있다.</p> <ul><li>null</li> <li>undefined</li> <li>boolean</li> <li>number</li> <li>string</li> <li>object</li> <li>symbol</li></ul> <p>잠깐 <code>Symbol</code> 이란?</p> <ul><li>A unique value that can be used as an identifier for object properties</li></ul> <p>쉽게 말해 <strong>unique 한 값을 저장하는 컨테이너</strong>이다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> s <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token number">555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 555</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>원시 값은 모두 typeof 로 확인 할 수 있다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 타입은 자신의 명칭과 동일한 문자열을 반환 */</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token operator">===</span> <span class="token string">&quot;undefined&quot;</span> <span class="token comment">// true;</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token operator">===</span> <span class="token string">&quot;boolean&quot;</span> <span class="token comment">// true</span>
<span class="token keyword">typeof</span> <span class="token number">42</span> <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span> <span class="token comment">// true</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span>life <span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token comment">// true</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;symbol&quot;</span> <span class="token comment">// true</span>
<span class="token comment">/* 특별한 녀석 */</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span>
<span class="token keyword">typeof</span> <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* some codes */</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token comment">// Object 하위 타입</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token comment">// Object 하위 타입</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>null</code> 은 <strong>falsy</strong>한 유일한 원시 값이지만 <strong>타입은 Object</strong>인 특별한 존재이다. 따라서, 정확하게 확인하려면</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">!</span>a <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>와 같이 두개의 조건이 필요하다.</p> <p><code>Natives</code> 란 특정 환경 (브라우저 등의 클라이언트 프로그램)에 종속되지 않은, ECMAScript 명세의 <strong>내장 객체</strong> 를 의미 합니다. (사실 내장 함수 이다).</p> <div class="language- extra-class"><pre><code>String()
Number()
Boolean()
Array()
Object()
Function()
RegExp()
Date()
Error()
Symbol() // ES6
</code></pre></div><h3 id="값-vs-레퍼런스-🌟"><a href="#값-vs-레퍼런스-🌟" class="header-anchor">#</a> 값 vs 레퍼런스 🌟</h3> <p><code>Value</code> : null, undefined, string number, boolean 같은 <code>Scalar Primitives</code> 는 언제나 <strong>값 복사 방식</strong>으로 할당/ 전달 된다.</p> <p><code>Reference</code> : 객체 (배열과 박싱된 객체 래퍼 전체)나 함수등 합성 값 <code>Compound Values</code> 은 할당/ 전달 시 반드시 <strong>레퍼런스 copy를 생성</strong>한다.</p> <p>간단한 예제를 보면</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 원시 값 2 *값 복사*</span>
b<span class="token operator">++</span>
<span class="token comment">// a : 2 b : 3</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> c <span class="token comment">// d 와 c 모두 [1,2,3] 의 레퍼런스이다</span>
d<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token comment">// c, d 모두 [1,2,3,4]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>null, undefined, string, number, boolean, symbol 같은 원시 값은 언제나 값 복사 방식으로 전달된다.</p> <p>배열 같은 합성 값을 값 복사에 의해 전달하려면</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token function">foo</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Shallow Copy</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>와 같이 레퍼런스가 원본을 가리키지 않게 해야함.</p> <p>반면, 스칼라 원시 값을 레퍼런스처럼 바뀐 값이 바로바로 반영되도록 넘기려면 원시 값을 달른 합성 값 (객체, 배열) 으로 감싸야 한다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">wrapper</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    wrapper<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a <span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token comment">//wrapper 없이 그냥 a를 전달할 경우 값이 변경되지 않음</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>자바스크립트에서 값 복사냐 레퍼런스 복사냐는 개발자가 정할 수 없고 전적으로 값의 타입을 보고 JS 엔진에 의해 결정된다.</p> <h3 id="불변성"><a href="#불변성" class="header-anchor">#</a> 불변성</h3> <p>JS 의 원시 값은 <code>Immutable</code> 합니다. 아래의 코드를 보면</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 3이 아닌 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>에서 Number 객체의 레퍼런스 사본(b) 가 전달되어 공유된 원시 값 2를 바꾸려 한다. 하지만 <strong>원시 값은 immutable</strong> 하기 때문에 2를 가진 Number 객체는 다른 원시 값을 가지도록 변경할 수 없다. 따라서 <strong>바깥의 b는 불변의 원시값을 가진 원본 Number 객체</strong>를 계속 참조한다.</p> <h3 id="래퍼객체"><a href="#래퍼객체" class="header-anchor">#</a> 래퍼객체</h3> <p>래퍼 객체는 <code>원시 값</code> <code>Primitives</code> 를 감싸는 객체이다.</p> <p>객체 래퍼는 아주 중요한 용도로 활용된다. 원시 값 &quot;abc&quot;에는 프로퍼티나 메서드가 없지만 JS가 알아서 <code>박싱 (래핑)</code> 하므로 아래와 같이 내부 함수를 쓸 수 있는 것이다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;ABC&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>JS 엔진이 객체를 생성할 필요 없도록 개발자가 직접 객체 형태로 <code>Pre-Optimize</code> 하면 오히려 더 느려질 수 있다. <strong>JS엔진이 알아서 박싱하도록 원시값을 사용</strong>하자.</p> <p>만약 수동으로 원시 값을 박싱하려면 Object() 함수를 이용하면 된다. 단 new 는 키워드는 없다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>

<span class="token keyword">typeof</span> a <span class="token comment">// &quot;string&quot;</span>
<span class="token keyword">typeof</span> b <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> c <span class="token comment">// &quot;object&quot;</span>

b <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>래퍼 언박싱은 valueOf() 메서드로 추출한다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;abc&quot;</span>
b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 42</span>
c<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>이러한 래퍼 언박싱은 <code>암시적 강제변환</code>에서 일어나기 때문에 중요하다. <a href="https://jeongshin.github.io/JeongShin_Blog/book-review/You_Don't_Know_JS/#ch-1-4-%EA%B0%95%EC%A0%9C%EB%B3%80%ED%99%98-%E2%AD%90%EF%B8%8F" target="_blank" rel="noopener noreferrer">강제변환 내용 더보기<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>출처 : <a href="https://books.google.co.kr/books/about/You_Don_t_Know_JS_Up_Going.html?id=3iWABwAAQBAJ&amp;source=kp_book_description&amp;redir_esc=y" target="_blank" rel="noopener noreferrer">You Don't Know JS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="step-3"><a href="#step-3" class="header-anchor">#</a> Step 3</h2> <h3 id="객체의-메서드-호출할-때-this-바인딩"><a href="#객체의-메서드-호출할-때-this-바인딩" class="header-anchor">#</a> 객체의 메서드 호출할 때 this 바인딩</h3> <p>객체의 프로퍼티가 함수일 경우, 이 함수를 메서드라고 부른다. 메서드를 호출할 때, <strong>메서드 내부에서 사용된 this 는 해당 메서드를 호출한 객체로 바인딩</strong> 된다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    name <span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
    <span class="token comment">// 이후에 다루겠지만 화살표 함수는 다르게 동작하니 유의해서 보도록 하자 ❗️</span>
    <span class="token function-variable function">sayName</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> otherObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    name <span class="token operator">:</span> <span class="token string">'bar'</span>
<span class="token punctuation">}</span>

otherObject<span class="token punctuation">.</span>sayName <span class="token operator">=</span> myObject<span class="token punctuation">.</span>sayName

myObject<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// foo</span>
otherObject<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// bar</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><br> <img src="https://www.plantuml.com/plantuml/svg/PP0zRW8n48NxESM8Pg600wm4uWHmXCWiiwo3xObiyoU45AM4beA2DgbIK214aHDbuGuOWHRGTlFqtllqD6tdXVKZhS0DfVaGLcZKR3Z9B6j2IsEoZa0enPCtBQVI302uzqw9Hpthteuv6172JOnwmaRWnAnprn4iYZZxZ6ofaJAN6s6K9woa8vDuoQPQgw1mc4AACIPi72jgA1vKVIPTuqggGV3gzTPZKroS_xjFF6-EfyFsjDhYjP8lruMRV_zXIEG_l-Ul_Htol3H-KMNEi_lWG9jCFtpr0W00" alt="uml diagram"> <p>위와 같이 sayName() 메서드에 사용된 <strong>this는 자신을 호출한 객체에 바인딩</strong> 되는걸 볼 수 있다.</p> <br> <br> <h3 id="내부함수에서의-this"><a href="#내부함수에서의-this" class="header-anchor">#</a> 내부함수에서의 this</h3> <p>내부함수에서 this는 <code>전역 객체</code>에 바인딩 된다.</p> <p><code>전역객체</code></p> <p>브라우저 환경에서 전역객체는 window 객체가 된다. Node.js에서는 global 객체가 된다.</p> <p>자바스크립트의 모든 전역 변수는 전역 객체의 프로퍼티가 된다. 아래의 예제를 보자</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token string">'this is test'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment">// 전역 객체의 프로퍼티가 됨</span>

<span class="token keyword">var</span> <span class="token function-variable function">sayFoo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>test<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">sayFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>예제에서 'this is test' 전역 객체에서 sayFoo를 호출하였기 때문에 this는 전역 객체로 바인딩 된다. 이때 this 바인딩 특성은 <strong>내부 함수 또는 callback 함수 호출했을 경우</strong>
에도 그대로 적용된다.</p> <h3 id="예제-1-내부-함수가-전역-객체에-바인딩"><a href="#예제-1-내부-함수가-전역-객체에-바인딩" class="header-anchor">#</a> 예제 1 : 내부 함수가 전역 객체에 바인딩</h3> <br> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    value <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">func1</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func1 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func2 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token function-variable function">func3</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func3 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
myObject<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">/* 출력 결과
func1 called value is 2
func2 called value is 101
func3 called value is 102
*/</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5N8pS_BJyueoizDLIXABKijAaxbIip9oI_FpQp8p4ldoa_AIaqkKSYjz8SmghdA4dDAKnLi5OouqahpaWs1h6YjMAvQBfZIyioybFno98M61WOWQQ3T9QaAIc1D6feAhrTEUTCov_NaEKeAYSKAQSZIHY3ffYsljpMydRhYJSSCY0f3P2N6M9K0dQIWgsk7SAsLGab6PZ5NcY5O6EeocA0H5a4kXzIy56000G00" alt="uml diagram"> <p>예제 1에서는 내부 함수 호출 패턴이 정의되어 있지 않기 때문에 내부 함수가 호출 될 때, <strong>this 는 전역 객체 window에 바인딩</strong> 된다.</p> <p>만약 내부 함수에서 myObject 를 접근하려면 <strong>부모 함수의 this</strong> 를 내부 함수가 접근 가능한 <strong>다른 변수에 저장</strong>하여 내부 함수가 전역 객체를 참조하는걸 극복할 수 있다. 예제 2를 보자.</p> <h3 id="예제-2-that-을-이용한-this-바인딩"><a href="#예제-2-that-을-이용한-this-바인딩" class="header-anchor">#</a> 예제 2 : that 을 이용한 this 바인딩</h3> <br> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    value <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">func1</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token comment">/* ⭐️ 스코프 체이닝으로 인해 내부 함수는 외부 변수 that 에 접근 할 수 있다
        that 은 myObject this를 참조한다.
        즉, 이후 that으로 myObject value를 접근 가능해진다. */</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func1 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            that<span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func2 called value is '</span> <span class="token operator">+</span> that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token function-variable function">func3</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                that<span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func3 called value is '</span> <span class="token operator">+</span> that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
myObject<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">/* 출력 결과
func1 called value is 2
func2 called value is 3
func3 called value is 4
*/</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5N8pS_BJyueoizDLIXABKijAaxbIip9oI_FpQp8p4ldoa_AIaqkKSYjz8SmghdA4dDAKnLi5GovqahpaWs1h6YjMAvQBg3P9QaAIc113Ks5rokdl6cPytho72M5n6A5D6Hf8v1qqvRNsnhUJbtnfcC6H8KXiX9Zh4gCkD8KT7Nj4AwnKYZ9o2pcIZC42wU1-OabN6b6g7o7rBmKeAy1" alt="uml diagram"> <p>자바스크립트는 이와 같은 this 바인딩의 한계를 극복하기 위해 this 바인딩을 명시적으로 할 수 있도록 <code>call</code> 과 <code>apply</code> 메서드를 제공한다.</p> <p>jQuery, underscore.js 등의 라이브러리는 <code>bind</code> 라는 메서드를 통해 사용자가 <strong>원하는 객체를 this에 바인딩</strong>하도록 돕는다.</p> <p>👉 책에는 bind 메서드가 라이브러리를 통해 사용할 수 있다 되어 있는데 ES5 부터 Function.prototype.bind 로 정의 되어 있습니다.</p> <h3 id="call-과-apply-메서드를-이용한-명시적-this-바인딩"><a href="#call-과-apply-메서드를-이용한-명시적-this-바인딩" class="header-anchor">#</a> call 과 apply 메서드를 이용한 명시적 this 바인딩</h3> <p>지금까지는 this 바인딩이 JS에 의하여 자동으로 바인딩 되었지만 이번 예제에선 함수 객체 기본 프로퍼티인 apply() 와 call() 을 이용하여 명시적으로 this를 바인딩 한다.
모든 함수는</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> argArray<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>와 같이 호출이 가능하다. apply() 메서드를 호출하는 주체는 함수이고 apply() 메서드도 this를 특정 객체에 바인딩할 뿐 <strong>본질은 함수 호출</strong> 이다.</p> <p>첫번째 인자 <code>thisArg</code> 는 호출한 함수 내부에서 사용한 <strong>this에 바인딩할 객체</strong>를 가리킨다. 즉, 첫번째 인자가 this로 명시적이게 바인딩 된다.</p> <p>두번째 인자 <code>argArray</code> 는 호출할 때 넘길 인자들의 배열을 가리킨다.</p> <p>즉, apply() 메서드는 (명시적 this, 인자 배열) 을 인자로 함수를 호출하는 셈이다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span> <span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> gender</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender
<span class="token punctuation">}</span>
<span class="token comment">// 리터럴로 생성한 빈 객체</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// foo 를 this 로 바인딩</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'man'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'man'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>위와 같이 원하는 값을 명시적으로 바인딩하여 특정 함수나 메서드에서 접근이 가능하다.</p> <p>가장 대표적인 예로 <code>유사 배열 객체</code>에서 사용하는 배열 메서드가 있다. <code>arguments 객체</code>는 실제 배열이 아니기 때문에 pop(), shift() 같은 배열의 메서드를 사용할 수 없다. 하지만 apply() 를 사용하면 가능하다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
    <span class="token comment">// arguments.shift() 👉 Error 🤯</span>
    <span class="token comment">// arguments 객체를 배열로 변환</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
    <span class="token comment">// 또는 ES6 Array.from(arguments) 도 가능</span>
    console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
    <span class="token comment">// __proto__ 프로퍼티가 Array로 바뀐걸 확인 가능</span>
<span class="token punctuation">}</span>
<span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>this에 대한 개념은 생성자 함수에서도 중요한 역할을 한다. JS 생성자 작동방식에 대해 알아보자.</p> <h3 id="생성자-함수-동작-방식"><a href="#생성자-함수-동작-방식" class="header-anchor">#</a> 생성자 함수 동작 방식</h3> <p>JS에서는 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작하게 된다. 즉, new를 잘못사용하게 되면 원하지 않는 생성자를 실행할 수도 있다.</p> <p>대부분의 자바스크립트 스타일 가이드에서는 생성자 함수의 첫 이름을 대문자로 쓰길 권하고 있다. 생성자 함수에서 this는 이전에 다루었던 this 바인딩과는 다르게 동작한다.</p> <div class="custom-block tip"><p class="custom-block-title">new 연산자로 함수 호출시 동작 방식</p> <ol><li><p>빈 객체 생성 및 this 바인딩</p> <ul><li>가장 먼저 빈 객체가 생성된다</li> <li>이 객체는 this로 바인딩 된다</li> <li>따라서 생성자 함수 코드 내부에서 this 는 이 빈 객체를 가리킨다</li> <li>여기서 엄밀히 따지면 빈 객체는 아니다 (아래 내용 참고)</li></ul></li></ol> <p><code>JS 객체 생성 규칙</code>
👉 JS에서 모든 객체는 자신의 부모인 프로토 타입 객체와 연결되어 있으며
부모의 프로퍼티나 메서드를 사용할 수 있는데 생성자 함수가 생성한 객체는
자신을 생성한 <strong>생성자 함수의 prototype 프로퍼티가 가리키는 객체</strong>를
<strong>자신의 프로토 타입 객체로 설정</strong>한다</p> <ol start="2"><li><p>this를 통한 프로퍼티 생성</p> <p>이후에 함수 코드 내부에서 this를 사용하여 앞에서 생성된 <strong>빈 객체에 동적으로 프로퍼티나 메서드를 생성</strong>할 수 있게 된다</p></li></ol> <ol start="3"><li><p>생성된 객체 리턴</p> <p>가장 일반적인 경우 특별한 리턴문이 없는 경우 <strong>this 로 바인딩 된 새로 생성한 객체가 리턴</strong>된다. 이는 명시적으로 this를 리턴한 값과 동일하다.
this 가 아닌 객체를 리턴하는건 이후에 다루도록 한다.</p></li></ol></div> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 생성자 함수는 관례적으로 첫 글자는 대문자 이름 사용</span>
<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ⭐️ 아래 코드가 실행되기 전에 빈 객체를 생성 후 Person() 의
    prototype 프로퍼티가 가리키는 객체, Person.prototype,
    를 [[Prototype]] 링크로 연결하여
    자신의 프로토타입으로 설정 후 this로 바인딩 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token comment">/* this가 가리키는 빈 객체에 동적으로 name 프로퍼티 생성 */</span>
    <span class="token comment">/* 특별히 리턴값이 없는 경우 this로 바인딩된 이 객체가 리턴됨 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="리터럴-vs-생성자-객체-생성"><a href="#리터럴-vs-생성자-객체-생성" class="header-anchor">#</a> 리터럴 vs 생성자 객체 생성</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 리터럴 방식 : 1 번만 생성 가능</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    name <span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
    age <span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>
    gender <span class="token operator">:</span> <span class="token string">'man'</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>

<span class="token comment">/* 출력 결과
Object
age: 35
gender: &quot;man&quot;
name: &quot;foo&quot;
__proto__: Object */</span>

<span class="token comment">// 생성자 함수 : 여러번 생성 가능</span>
<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender
<span class="token punctuation">}</span>

<span class="token comment">// Person 생성자 객체 생성</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span> <span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token string">'woman'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>

<span class="token comment">/* 출력 결과
Person
age: 33
gender: &quot;woman&quot;
name: &quot;bar&quot;
__proto__: Object */</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>리터럴 방식과 생성자 방식의 차이는 프로토타입 객체 (<code>__proto__</code> 프로퍼티) 에 있다. 객체 리터럴의 경우 <code>Object.prototype</code> 을 생성자의 경우 <code>Person.prototype</code> 을 프로퍼티로 가진다.</p> <p>이는 위에서 설명한 <code>JS 객체 생성 규칙</code> 에 따라 리터럴에선 객체 생성자가 Object() 이고 생성자에선 생성자가 Person() 함수이기 때문이다.</p> <div class="custom-block tip"><p class="custom-block-title">생성자 함수를 new 없이 호출하면 어떤 사악한 일이 일어날까? 👿</p> <p>new 를 이용한 생성자 함수에서 this는 빈 객체에 바인딩 된다고 위에서 다루었다.
하지만 new 키워드 없이 생성자 함수를 호출하게 되면 빈 객체가 아닌 글로벌 객체에 this가 바인딩 되어
글로벌 객체에 프로퍼티를 생성한다. 즉, 끔찍한 일이 발생한다. 주의하자 !</p></div> <p>출처 : <a href="http://www.yes24.com/Product/Goods/37157296" target="_blank" rel="noopener noreferrer">Inside Javascript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="화살표-함수-arrow-function"><a href="#화살표-함수-arrow-function" class="header-anchor">#</a> 화살표 함수 - Arrow Function</h3> <p>화살표 함수는 ES6 부터 지원된 익명 함수로 간결하고 짧은 구문으로 표현할 수 있습니다. 특징을 2가지 정리해보았습니다.</p> <div class="language- extra-class"><pre><code>1. 생성자로 사용할 수 없다
2. this 바인딩을 하지 않는다
</code></pre></div><ol><li>자바스크립트 생성자</li></ol> <p>자바스크립트에서는 new 키워드와 함수명을 더해주어 해당 함수를 생성자로 사용한다. 하지만 화살표 함수는 <strong>생성자로 사용할 수 없다</strong>.</p> <ol start="2"><li>바인딩 되지 않은 this</li></ol> <p><strong>일반 함수</strong>의 경우 모든 새로운 함수는 자신의 <strong>this 값이 JS 엔진에 동적</strong>으로 정해진다. strict mode 에서는 undefined, 생성자에선 새로운 객체, 함수가 객체 메서드로 호출된 경우 해당 함수를 호출한 객체가 할당된다.</p> <p>반면 익명 함수인 화살표 함수는 <strong>this 가 정해지지 않는다</strong> (일반 함수와 다르게 정해진다가 더 정확한 표현인거 같습니다).</p> <p>즉, 객체지향 관점에서 별로 좋지 않다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 생성자로 사용된 함수에서 this는 새로 만들어진 객체를 의미 (JS 생성자 작동방식 참고).</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token function">setInterval</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">growUp</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 비엄격모드 에서 this 는 Person 내부 this 가 아닌 전역 객체로 바인딩 됨</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>이에 대한 해결방법으로 관례적으로 사용하는 변수 <code>that</code> 을 선언해주거나 bind() 함수등을 사용하여 해결 해왔습니다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
    that<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token function">setInterval</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">growUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        that<span class="token punctuation">.</span>age<span class="token operator">++</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>다시 화살표 함수로 돌아오자. 화살표 함수는 전역 컨텍스트에서 실행될 때 this 가 새로 정의되지 않는다.</p> <p>대신 코드 바로 바깥 함수 또는 class 의 this 값이 사용 된다. 이는 this 가 실행 컨텍스트에 따라 동적으로 바인딩 되는 일반 함수와 다르게 <strong>화살표 함수는 화살표 함수의 상위 스코프 this</strong> 를 가리킨다. 이를 <code>Lexical this</code> 라 부릅니다.</p> <p>이때 this 는 클로저 값으로 처리하는것과 같이 동작한다. 예제로 보면</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token function">setInterval</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// this 는 상위 스코프 this, 즉, 생성자 함수에서 생성된 새로운 객체 가르키기 때문에</span>
        <span class="token comment">// 위의 this.age 가 됨.</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>맨위 내부 함수의 전역 객체 this 바인딩을 다시 떠올려보자. 만약 모든 함수가 화살표 함수로 정의 되어 있었다면?</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    value <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">func1</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func1 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token comment">/* Lexical this 👉 스코프에서 this 를 정적으로 바인딩*/</span>
        <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func2 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token function-variable function">func3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'func3 called value is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
myObject<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">/* 출력 결과
func1 called value is 2
func2 called value is 3
func3 called value is 4
*/</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>와 같이 func1 에 this가 바인딩 되어 위와 같은 출력 결과를 얻었다.</p> <div class="custom-block tip"><p class="custom-block-title">엄격모드와 관계</p> <p>this 가 렉시컬 this 로 동작하기 때문에 this 에 관한 엄격 모드 규칙이 그냥 무시된다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token string">'use strict'</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> window <span class="token comment">// 혹은 전역 객체 출력 : true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>this에 관련 없는 나머지 규칙들은 그대로 적용된다.</p></div> <h4 id="화살표-함수에서의-call-apply-bind"><a href="#화살표-함수에서의-call-apply-bind" class="header-anchor">#</a> 화살표 함수에서의 call, apply, bind</h4> <p>위에서 다룬 화살표 함수 특징에 따라 this 가 바인딩 되지 않기 때문에 call(), apply() 를 통해 인자만 전달하고 this는 무시 된다. 즉, this 의 값을 바꿀 수 없다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>window<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">generalFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">arrowFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">generalFunction</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// this 가 현재 오브젝트에 바인딩됨. 따라서 x 값이 10으로 바뀜</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">arrowFunction</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// this 가 무시됨. 따라서 x 값은 그대로 1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="화살표-함수에서의-arguments-객체"><a href="#화살표-함수에서의-arguments-객체" class="header-anchor">#</a> 화살표 함수에서의 arguments 객체</h4> <p>화살표 함수는 arguments 객체 또한 바인딩하지 않음. 따라서 arguments 키워드는 스코프내에서 확인자에 대한 참조가 됨.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arguments <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> <span class="token function-variable function">printFirstArg</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span>
<span class="token function">printFirstArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>하지만 대안으로 나머지 매개변수를 사용할 수 있음.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arguments <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 화살표 함수에 나머지 매개변수를 통해 명시적으로 인자 전달</span>
    <span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> n
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><s>정리하면서 포함한 내용이지만 그닥 쓸모 있어보이진 않습니다.</s></p> <h4 id="메소드로-화살표-함수-⭐️"><a href="#메소드로-화살표-함수-⭐️" class="header-anchor">#</a> 메소드로 화살표 함수 ⭐️</h4> <p>위의 특징을 알았다면 다음의 내용을 이해할 수 있다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name <span class="token operator">:</span> <span class="token string">'JeongShin'</span><span class="token punctuation">,</span>
    <span class="token comment">// this 가 해당 객체에 바인딩 되지 않고 전역 객체를 가리킴</span>
    <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hi my name is undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>이러한 경우 <code>ES6 축약 메소드 표현</code>을 사용하여 아래와 같이 코딩하자</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name <span class="token operator">:</span> <span class="token string">'JeongShin'</span><span class="token punctuation">,</span>
    <span class="token comment">// 일반 메소드 축약 표현</span>
    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hi my name is JeongShin</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>위의 <strong>일반 함수가 해당 메서드를 호출한 함수에 this 가 바인딩 되는것과 다르게 동작</strong>한다.</p> <h4 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h4> <p>화살표 함수는 prototype이 없다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="화살표-콜백-함수"><a href="#화살표-콜백-함수" class="header-anchor">#</a> 화살표 콜백 함수</h4> <p>콜백 함수를 화살표 함수로 정의하면 아래와 같은 실수가날 수 있다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// this 가 전역 객체에 바인딩</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'btn clicked'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>화살표 함수에서 this 는 전역 객체이다. 따라서 btn 에 this 를 바인딩 하기 위해서는</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> btn<span class="token punctuation">)</span> <span class="token comment">// this 가 btn 에 바인딩</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'btn clicked'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>와 같이 해주면 된다.</p> <p>출처 : <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98" target="_blank" rel="noopener noreferrer">Mozilla Developer : MDN web docs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> , <a href="https://poiemaweb.com/es6-arrow-function" target="_blank" rel="noopener noreferrer">PoiemaWeb : 웹 프로그래밍 튜토리얼<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JeongShin_Blog/TIL/study/" class="prev router-link-active">
        WEB 🌏
      </a></span> <span class="next"><a href="/JeongShin_Blog/TIL/study/NodeJS.html">
        Node JS
      </a>
      →
    </span></p></div>  <div><div id="comment"></div></div></main> <footer class="siteFooter">
  COPYRIGHT©2020 ALL RIGHT JeongShin
  <br>sjeong1127@gmail.com . +82-10-2169-2142 .
  <br> <a href="https://www.instagram.com/jeongshin96/" target="_blank">Instagram</a> <a href="https://github.com/JeongShin" target="_blank">GitHub</a></footer></div><div class="global-ui"></div></div>
    <script src="/JeongShin_Blog/assets/js/app.02edf619.js" defer></script><script src="/JeongShin_Blog/assets/js/2.d8f9045d.js" defer></script><script src="/JeongShin_Blog/assets/js/9.e8039219.js" defer></script>
  </body>
</html>
