# 데이터베이스

## 데이터베이스 기초

### 데이터 모델 분류

- 관계형 데이터 모델

관계형 데이터 모델은 테이블(릴레이션)의 형식으로 표현하는 확실한 이론적 기반과 간결한 표현형식으로 **가장 많은 상용 DBMS가 사용**한다.

- 객체지향 데이터 모델

데이터 구조가 복잡하여 관계형 모델이 부적당한 경우 데이터를 클래스 단위로 표현하여 상속, 캡슐화 등의 객체 지향 개념을상도입하고 있다.

- 계층형 데이터 모델

데이터를 트리 구조로 표현하며 각 노드가 레코드가 된다.

- 네트워크 데이터 모델

계층형을 보완한 모델로 트리가 아닌 그래프 형태로 표현한다.

### 스키마와 인스턴스

`스키마`

👉 메타 데이터와 같은 의미로 데이터 베이스의 구조에 대한 정보를 의미한다. 대부분 데이터베이스 설계과정에서 정의되며 자주 변경되지 않는 특징을 가진다.

👉 스키마는 데이터 항목, 데이터 타입과 같은 구조와 데이터가 만족해야할 제약 조건까지 포함한다.

`인스턴스`

👉 스키마에 대한 실제 데이터를 인스턴스라 한다.

### 스키마 아키텍처

1. 논리적 단계 : 논리적 스키마

논리적 단계에서는 전체 데이터 베이스의 논리적 구조를 기술한다. 논리적 스키마는 논리적 데이터 모델을 사용하며 관계형 모델의 경우에는 데이터베이스 테이블들의 집합 및 제약조건들로 표현된다.

2. 내부 단계 : 내부 스키마

내부 단계에서는 데이터베이스의 물리적 구조를 기술한다. 데이터 저장 구조의 세부 사항과 데이터 접근 경로들을 기술한다.

3. 외부 단계 : 외부 스키마

사용자 뷰에 해당한다. 사용자가 관심을 갖는 데이터베이스의 부분을 기술하고 나머지는 숨긴다.

### 데이터의 독립성

3 단계 스키마 아키텍처를 통해 상위 스키마와 하위 스키마가 매핑을 통해 **데이터의 독립성**을 제공할 수 있다.

`물리적 데이터 독립성`

논리적 스키마 또는 외부 스키마의 정의를 변경할 필요 없이 물리적 스키마를 수정할 수 있는 능력을 의미한다.

예를들어, 학사 DB에서 전공 별 학생들에 대한 데이터 검색이 빈번한 경우, 학생 테이블을 전공에 대해 정렬한든지 인덱스를 추가하여 논리적 스키마를 변경하지 않아도 성능을 향상시킬 수 있다.

`논리적 데이터 독립성`

외부 스키마의 정의를 변경할 필요 없이 논리적 스키마를 수정 할 수 있는 능력.

예를들어 학생 테이블의 경우 새로운 응용 프로그램의 개발을 위해 학년을 나타내는 속성을 추가한다고 기존 응용 프로그램은 수정할 필요가 없다.

`데이터 추상화`

응용 프로그램에서는 데이터의 물리적 구조나 상세한 내용은 알 필요가 없음. 따라서 추상화를 통해 필요한 데이터만 제공.

## 트랜잭션

데이터베이스 시스템은 다수의 사용자에 대해서도 데이터에 대한 동시적 접근 상황에서 항상 데이터의 알관성이 유지되어야 하며 혹시나 발생하는 시스템 장애에도 데이터의 손실이 없어야 한다.

정의 👉 일련의 데이터베이스 연산들로 이루어진 논리적인 연산 단위

:::tip 트랜잭션의 ACID 특징  
A - Atomicity

All or Nothing, 즉, 모든 연산이 완전히 수행되든지 전혀 수행되지 않아야 한다.

C - Consistency

완료한 트랜잭션은 시스템 장애 발생 시에도 그 효과가 지속적이어야 함

I - Isolation

트랙잭션의 효과가 다른 트랜잭션의 영향으로부터 독립적이어야 함

D - Durability
:::

출처 : 단국대학교 소프트웨어학과 이석균 교수님 - 데이터 베이스 기초, 고급 데이터 베이스 자료내용

## 무결성 제약 조건

### 무결성 제약 조건이란?

데이터베이스 스키마에 대하여 지정되는 조건으로 데이터베이스에 저장되는 데이터들이 반드시 만족해야 할 조건을 의미한다.

관계형 모델에서의 무결성 제약 조건

👉 도메인 제약 조건 - Domain Constraint

각 속성의 도메인을 지정하여 입력 오류 방지한다. SQL 은 다양한 타입을 제공하여 도메인 제약 조건을 지원한다.

하지만 가령 학생들의 성적 같은 경우 A, B, C, D, F 의 알파벳으로만 표현된다고 가정하면 다른 문자들이 오는걸 막아야 한다. 이러한 경우 아래와 같은 경우 **check 절** 을 활용할 수 있다.

```sql
CREATE TABLE Course_Taken (
    grade CHAR CHECK (grade IN ('A', 'B', 'C', 'D' , 'F'));
)
```

### 키 제약 조건 - Key Constraint

키(key)는 릴레이션의 투플을 유일하게 식별할 수 있는 속성을 의미한다. 키는 다음과 같은 특징을 가진다.

- 유일성 (unqueness) 보장 : 릴레이션의 어떤 두 투플도 키를 구성하는 모든 속성에 대해 동일한 값을 가질 수 없다.

- 최소 집합 (minmal set) 요건 : 키를 구성하는 속성의 어떤 부분집합도 투플의 유일성을 보장하지 못한다.

  - Ex) 학과DB에서 {학번, 이름} 과 {학번} 이 두가지 case 모두 투플들의 유일성을 보장할 수 있다. 하지만 {학번, 이름}의 경우 최소집합 요건을 만족시키지 않는다.

### 키의 종류 및 조건

Candidate Key 👉 단일 인스턴스를 유일하게 식별해주는 하나의 필드 또는 집합이다. 각 테이블은 적어도 하나의 후보키를 가져야만 한다.

Super Key 👉 릴레이션에서 유일성을 보장하는 속성은 모두 superkey 가 된다. 위에서 다루었던 { 학번 }, { 학번, 이름 } 모두 superkey 가 된다. 이때 주의할점은 모든 super key 가 primary key 가 되는건 아니다.

Primary Key 👉 후보키 중 하나의 키가 기본키가 되고 나머지는 후보키가 된다. Primary Key 절을 사용한다.

Alternate Key 👉 후보키 중 기본키를 제외한 키, Unique 절 사용

**후보키 (기본키)의 요소**

- 유일한 값을 포함한다.
- 널 값을 포함할 수 없다.
- 보안이나 비밀을 깨틀리지 않는다. (주민등록번호 같은 값들은 후보 키로 부적합)
- 다중필드가 아니다.
- 아주 드물고 극단적인 경우에만 수정될 수 있다.

### 개체 무결성 제약조건 - Entity Integrity Constraint

개체 무결성 제약조건은 **기본키에는 NULL 이 올 수 없음**을 의미한다.

DB에서의 `NULL` 의 개념

1. Unknown 의 의미

   - 아직 기록이 되지 않거나, 값이 존재하나 누락된 경우, 실제 존재하는지 여부를 모르는 경우 알려지지 않음의 의미로 NULL이 쓰인다.

2. Inapplicable 의 의미

   - 데이터 개체가 속성을 가질 수 없는 경우에 해당한다.
   - 예를들어 대학교 수업 강사 또는 교수의 데이터에서 강사들의 경우 연구실이 없고 교수만 연구실이 있다고 가정하면 강사들은 연구실 필드에 널 값이 올 수 있다.

기본 키에는 NOT NULL 절 사용

```sql
CREATE TABLE Student (
    id CHAR(8) NOT NULL, /* 개체 무결성 제약조건 */
    ssn CHAR(13) NOT NULL,
    name CHAR(10) NOT NULL,
    major CHAR(4),
    gpa FLOAT NOT NULL DEFAULT 0.0,
    UNIQUE(ssn), /* 키 제약 조건, 후보키 제약 */
    PRIMARY KEY(id); /* 키 제약 조건, 기본키 제약 */
)
```

### 외래키 제약조건 - Referential Integrity Constraint

외래키는 **다른 테이블의 기본키 값**을 가지는 속성을 의미한다.

- 자식 (child) 테이블 : 외래키를 포함하는 테이블
- 부모 (parent) 테이블 : 외래키가 가리키는 기본키를 갖는 테이블

외래키 제약조건은 NULL 또는 외래키의 값과 같은 값을 기본키 값으로 갖는 투플이 부모 테이블에 존재해야 한다.

```sql
CREATE TABLE Student (
    id CHAR(8) NOT NULL,
    major CHAR(4),
    UNIQUE (ssn),
    PRIMARY KEY(id);
    FOREIGN KEY(major) REFERENCES Department(id)
)
```

위의 예제의 경우 major (전공)은 department 테이블의 기본키인 id 값을 참조하게 되는 경우이다.

⭐️ **외래키 제약 조건 위반 사례**

- Department 에 없는 전공 값의 투플을 Student 에 입력할 때 👉 자식 테이블에서 위반 🙅🏻‍♂️
- Student 에서 참조하는 전공의 투플을 Department 에서 삭제할 때 👉 부모 테이블에서 위반 🙅🏻‍♂️
- Student 에서 참조하는 전공의 값을 Department 에서 변경 할 떄 👉 부모 테이블에서 위반 🙅🏻‍♂️

2,3 번의 경우 부모 테이블에서 외래키 제약 조건을 위반하는 경우 **DBMS 정책이** 있다.

1. No Action : Parent 의 갱신 작업을 허용하지 않는다 (디폴트)
2. Set Null : Parent 의 갱신에 대해 Child의 외래키를 NULL로 설정

```sql
CREATE TABLE Student (
    FOREIGN KEY(major) REFERENCES Department(id) ON DELETE SET NULL;
)
```

3. Set Default : Set NULL 과 유사함 NULL 대신 Default 값을 설정

4. **Cascade** : DELETE 연산의 경우 부모 테이블로부터 튜플들이 삭제될 때 자식 테이블 중 이 튜플을 참조하는 값들을 **연쇠적으로 삭제**한다. UPDATE 연산의 경우 자식 테이블의 외래키의 속성 값을 부모 테이블의 수정된 기본키의 속성 값으로 **연쇄적으로 수정**한다.

```sql
FOREIGN KEY (major) REFERENCES Department(id)
    ON DELETE SET NULLㅈ
    ON UPDATE CASCADE;
```

## 정규화

관계형 데이터베이스의 설계과정에서 **redundancy를 최소화** 하고 데이터를 구조화 하는걸 정규화 (normalization) 이라고 한다.

### 정규화를 해야하는 이유 ⁉️

정규화를 전혀 고려하지 않은 데이터베이스의 경우 불필요한 데이터 중복이 발생 (redundancy) 할 수 있고 데이터 중복으로 인해 공간도 낭비될 뿐만아니라 `Anomaly` 가 발생할 수 있다.

👉 Insertion Anomaly

| id  |  이름  |    강의명    |   담당 교수   |
| :-: | :----: | :----------: | :-----------: |
|  1  | 신정웅 | 데이터베이스 | 이석균 교수님 |
|  2  | 정익효 | 데이터베이스 | 이석균 교수님 |
|  3  | 지영본 | 데이터베이스 | 이석균 교수님 |

위와 같은 데이터가 있다고 가정해보자. 이때 새로운 학생이 데이터베이스 수업에 추가되면 또 같은 값에 대한 Insertion 이 이루어 진다. 아직까진 그렇게 큰 문제가 아닐 수 있다.

👉 Deletion Anomaly

| id  |  이름  |    강의명    |   담당 교수   |
| :-: | :----: | :----------: | :-----------: |
|  1  | 신정웅 | 데이터베이스 | 이석균 교수님 |

위의 데이터에서 지영본, 정익효 학생의 수강 내역이 삭제되었다고 가정해보자. 이때 마지막 남은 신정웅 학생의 수강내역 마저 삭제가 되면 데이터베이스 강의명과 담당교수에 대한 데이터가 아예 없어진다. 즉, 없는 수업이 되어 버린다.

데이터베이스에서 수강내역만을 삭제했을 뿐인데 강의에 대한 데이터까지 전부 삭제되는 불상사가 발생한 것이다.

👉 Updation Anomaly

| id  |  이름  |    강의명    |        담당 교수         |
| :-: | :----: | :----------: | :----------------------: |
|  1  | 신정웅 | 데이터베이스 | ~~이석균~~ 우진운 교수님 |
|  2  | 정익효 | 데이터베이스 |      이석균 교수님       |
|  3  | 지영본 | 데이터베이스 | ~~이석균~~ 우진운 교수님 |

만약 위와 같이 데이터베이스 수업 담당 교수가 이석균 교수님에서 우진운 교수님으로 바뀌었다고 가정해보자.

그렇다면 중복된 이석균 교수님에 대한 모든 데이터가 다 update 되어야 한다. 만약 위와 같이 1개라도 제대로 update가 이루어지지 않으면 담당 교수는 이석균 교수님인지 우진운 교수님인지 혼돈에 휩싸일 수 있다.

데이터베이스 정규화는 단계별로 이루어진다. 하나씩 알아보자.

### 1NF - First Normal Form

1NF 혹은 First Normal Form 은 가장 기초적인 정규화 단계이다. 1NF 조차 지켜지지 않은 데이터베이스는 설계가 아주 잘못되었다고 볼 수 있다.

따라서 데이터베이스에서 모든 테이블은 **최소한의 조건**으로 1NF는 항상 만족해야한다.

👉 Rule 1

모든 필드, 행은 **atomic values** 를 가져야 한다.

| Col 1 |  Col 2   | Col 3 |
| :---: | :------: | :---: |
|   A   | **X, Y** |   Z   |
|   B   |    W     |   F   |
|   C   |    D     |   F   |

위의 경우 X, Y 값을 동시에 가지기 때문에 위반 사례가 된다.

👉 Rule 2

모든 필드의 값들은 같은 타입을 가져야 한다.

|   생일   |  이름  | 성별 |
| :------: | :----: | :--: |
| 96-11-27 | 지영본 |  여  |
| 08-07-09 | 정익효 |  남  |
|  **R**   | 이현수 |  남  |

👉 Rule 3

모든 행들은 유니크한 Name (필드 명) 을 가져야 한다.

|   생일   | 이름 ❌ 성 ⭕️ | 이름 |
| :------: | :------------: | :--: |
| 96-11-27 |       지       | 영본 |
| 08-07-09 |       정       | 익효 |
| 95-03-11 |       이       | 현수 |

같은 한 테이블에 필드명을 가지게 되면 많은 혼란을 초래할 수 있다.

### 2NF - Second Normal Form

2NF 이해하기 위해서는 `partial dependency` 에 대한 개념이 필요하다.

아래와 같은 테이블이 있닥고 가정해보자.

|  학번   |  이름  |  학과  |
| :-----: | :----: | :----: |
| 1324981 | 지영본 | 도예과 |
| 4358941 | 정익효 | 도예과 |
| 1342818 | 이현수 | 성악과 |

이때 학번의 필드는 데이터를 Table에서 fetch 할때 해당 튜플을 유일하게 식별 가능하다.

예를들어 학번이 1324981인 학생의 학과를 조회할 때 학번으로 학생의 학과를 알아낼 수 있다.

따라서 다른 필드들 (이름, 학과) 이러한 필드 (학번, primary key)에 종속성을 가지게 된다. 이를 **dependency** 혹은 **functional dependency** 라고 말할 수 있다. 그렇다면 partial dependency 는 무엇일까?

Pratial Dependency 는 primary key 가 **composite key, 즉, 두개 이상의 필드가 키로 쓰일때** 발생할 수 있다.

다음과 같은 학생의 수강 내역을 저장하는 테이블이 있다고 가정하자.

|  학번   |  이름  |    강의명    | 성적 |   담당 교수   |
| :-----: | :----: | :----------: | :--: | :-----------: |
| 1324981 | 지영본 | 데이터베이스 |  A+  | ㅇㅇㅇ 교수님 |
| 4358941 | 정익효 |   알고리즘   |  B+  |  XXX 교수님   |
| 1342818 | 이현수 | 데이터베이스 |  F   | ㅇㅇㅇ 교수님 |

이때 학번 + 강의명이 primary key 로 사용될 수 있다. 그렇다면 종속성을 따져보자.

    {학번, 강의명} 👉 성적
    학번 👉 이름
    강의명 👉 담당 교수

> 따라서 담당교수 필드, 이름 필드 등은 primary key 에 대하여 부분적인 종속성, partial dependency 를 가지고 이는 2NF에 위반된다.

2NF는 이러한 partial dependency 를 없애는걸 의미한다. {학번, 이름}에 대한 테이블, {학번, 강의명, 성적} 에 대한 테이블, {강의명, 담당교수} 에 대한 테이블로 분리해주어 모든 기본키가 아닌 필드는 기본키에 대해서 `full functional dependency` 를 가지도록 설계해야 한다.

### 3NF - Third Normal Form

3rd Normal Form 은 `Transitive Dependency` 을 이해해야 한다. 이는 2NF 에서 다루었던 Partial Dependency 와는 다른 개념이다.

3NF 은 2NF이고, 키가 아닌 모든 속성들은 기본 키에 이행적 종속이 되지 않아야 한다.

다음과 같은 필드들의 테이블이 있다고 가정하자.

| 과목 번호 |    과목명    |       과목 설명        | 교수 ID |   교수 이름   | 연구실 |
| :-------: | :----------: | :--------------------: | :-----: | :-----------: | :----: |
|    CF5    | 데이터베이스 | 데이터베이스 기초 수업 |  P-442  | 이석균 교수님 | S-401  |

이때 종속성을 따져보자.

과목 번호 (기본 키) 에 과목명, 과목 설명, 교수 번호, 교수 이름, 연구실이 종속성을 가진다.

또한, 교수 번호 (키가 아닌 속성) 에 교수 이름, 연구실이 종속을 가진다.

즉, 연구실은 **과목 번호 👉 교수 ID 👉 연구실**

> A -> B 와 B -> C 이기 때문에 A -> C 라는 관계가 성립한다. 따라서 이러한 **이행적 종속**성이 3NF 위반 사례에 해당된다.

이는 교수 TABLE 과 과목 TABLE 을 분리하여 해결할 수 있다.

### BCNF - Boyce-Codd Normal Form

BCNF를 다루기전에 이전 정규화 단계에 대해 빠르게 복습해보자.

- 2NF - Partial Dependency

  - A 가 prime attribute, B가 non-prime attribute 일때,
  - AXY {후보키} 에 대하여 B 가 A 속성에 대하여 부분적으로 종속성을 가지면 위반

- 3NF - Transitive Dependency

  - A 가 non-prime attr, B가 non-prime attr 일때,
  - A 👉 B 가 종속성을 가지면 이행적 종속성을 가지게 되어 위반

  의 내용을 다시 한번 이해하고 BCNF 로 들어가자

BCNF 는 다음 두가지 조건을 만족해야 한다.

1. 3NF 를 만족해야 한다.
2. 모든 필드에 대하여 A 👉B 의 관계에서 **A 는 반드시 super key** 이어야 한다.

이에 따라 규칙 2를 위반하는 경우

> A 👉B 의 관계에서 A 가 non-prime 이지만 B 가 prime attribute 일때 BCNF 위반 사례가 된다.

아래와 같은 학생들의 수강 과목에 대한 테이블이 있다 가정해보자.

|   학번   |     과목      |   담당 교수   |
| :------: | :-----------: | :-----------: |
| 32162174 | 데이터베이스  | 이석균 교수님 |
| 32158320 | 글로벌 중국어 |  쯔위 교수님  |

위의 경우 종속성을 따져보자.

1. { 학번, 과목 } 👉 담당 교수
2. 담당 교수 👉 과목

두 가지 종속성에 대하여 두 종속성 모두 partial dependency, transitive dependency 가 없다.

하지만 BCNF 를 고려 해보면 **담당교수 (non - prime) 👉  과목 (prime)** 인 상황이다.

따라서 과목 속성이 super key가 아닌 속성에 의해 종속성을 가지고 있고 이는 BCNF 위반에 해당된다.

| 학번 | 과목ID |
| :--: | :----: |


| 과목ID | 담당 교수 | 과목명 |
| :----: | :-------: | :----: |


다음과 같이 2개의 테이블로 분리하고 과목 ID 속성을 참조하게 하여 BCNF를 만족시킬 수 있다.

### 4NF - Fourth Normal Form

4NF 는 `Multi-Valued Dependency` 에 대한 내용을 다룬다.

Multi-Valued Dependency 는 다음 3가지 조건을 만족할때 해당 된다.

1. A 👉B 종속 관계에서 하나의 A 에 대하여 하나 이상의 B가 존재한다.
2. 테이블은 3개 이상의 행으로 이루어져 있다.
3. 3개의 속성을 A, B, C 라 가정했을 때, B와 C는 independent하다(관계가 없다).

먼저 Single-valued Dependency 와 Multi-valued Dependency 에 대해 알아보자.

- Single-valued (One-to-One) Dependency

  - x -> y 인 관계
  - 예) 한명의 사람 (x) 은 하나의 주민등록번호 (y)를 가진다.

- Multi-valued (One-to-Many) Dependency

  - x ->> y 인 관계
  - 예) 한 학생(x)이 한 학기 동안 여러과목(y)을 수강할 수 있다.

### 함수적 종속에 의한 바람직한 분할 ⭐️

1. 무 손실 조인 분할 (lossless - join)

   - 분할된 테이블을 다시 조인 했을때, 원래의 테이블이 그대로 복원되어야 한다.

2. 종속 유지 분할 (dependency preserving)
   - 테이블을 분할한 결과로 생성된 테이블들을 원래 테이블이 가지고 있던 함수적 종속을 모두 가지도록 분할해야 한다.
   - 제 3정규형의 DB 스키마를 설계할 수 있다.

출처 : [위키 피디아](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94) [YouTube : Studytonight](https://www.youtube.com/watch?v=mUtAPbb1ECM)
