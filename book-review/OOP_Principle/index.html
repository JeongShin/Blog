<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>스프링 입문을 위한 자바 향의 원리와 이해 | JS Blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="JeongShin 의 코딩 블로그 👨🏻‍💻">
    <meta name="google-site-verification" content="66JKoxw93huqhAdXO3P0K86NJZne5H-M3302YHcwoWI">
    <link rel="preload" href="/JeongShin_Blog/assets/css/0.styles.bfee8014.css" as="style"><link rel="preload" href="/JeongShin_Blog/assets/js/app.c07b8bc6.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/2.0c6a2499.js" as="script"><link rel="preload" href="/JeongShin_Blog/assets/js/25.b3825ed9.js" as="script"><link rel="prefetch" href="/JeongShin_Blog/assets/js/10.0ef9b64a.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/11.2ea4c99c.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/12.71fa9b71.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/13.806dfd65.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/14.f26abe2e.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/15.06f79c41.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/16.d3f0ff51.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/17.eb668736.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/18.96b7a460.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/19.388f27c9.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/20.c3c62c7f.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/21.346de60b.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/22.1b550d1a.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/23.48670778.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/24.4f6bdb62.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/26.4789fe9f.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/27.8c70397e.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/28.929d6e19.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/29.23f72aa7.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/3.3d07a40e.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/30.35897d10.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/31.f93c0831.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/4.4d8eddec.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/5.27adf806.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/6.1bd7eab3.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/7.8b41307d.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/8.931ead73.js"><link rel="prefetch" href="/JeongShin_Blog/assets/js/9.8116f9a5.js">
    <link rel="stylesheet" href="/JeongShin_Blog/assets/css/0.styles.bfee8014.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/JeongShin_Blog/" class="home-link router-link-active"><img src="/JeongShin_Blog/images/logo.jpg" alt="JS Blog" class="logo"> <span class="site-name can-hide">JS Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JeongShin_Blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/JeongShin_Blog/home/" class="nav-link">
  
</a></div><div class="nav-item"><a href="/JeongShin_Blog/aboutme/" class="nav-link">
  About me
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/JeongShin_Blog/guide/" class="sidebar-link">Guide</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/TIL/" class="sidebar-heading clickable"><span>Today I Learned</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/algorithms/" class="sidebar-heading clickable"><span>Algorithms</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/book-review/" class="sidebar-heading clickable router-link-active open"><span>Book-Review</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/JeongShin_Blog/book-review/OOP_Principle/" aria-current="page" class="active sidebar-link">스프링 입문을 위한 자바 향의 원리와 이해</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JeongShin_Blog/book-review/OOP_Principle/#객체-지향-설계-5원칙-solid" class="sidebar-link">객체 지향 설계 5원칙 - SOLID</a></li><li class="sidebar-sub-header"><a href="/JeongShin_Blog/book-review/OOP_Principle/#스프링이-사랑한-디자인-패턴" class="sidebar-link">스프링이 사랑한 디자인 패턴</a></li></ul></li><li><a href="/JeongShin_Blog/book-review/You_Don't_Know_JS/" class="sidebar-link">You Don't Know JS</a></li><li><a href="/JeongShin_Blog/book-review/CoreJS/" class="sidebar-link">코어 자바스크립트</a></li><li><a href="/JeongShin_Blog/book-review/Inside_JS/" class="sidebar-link">인사이드 자바스크립트</a></li><li><a href="/JeongShin_Blog/book-review/EasyDB/" class="sidebar-link">가장 쉬운 데이터베이스 설계</a></li><li><a href="/JeongShin_Blog/book-review/Computing_System/" class="sidebar-link">밑바닥부터 만드는 컴퓨팅 시스템</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JeongShin_Blog/daily/" class="sidebar-heading clickable"><span>Daily</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="스프링-입문을-위한-자바-향의-원리와-이해"><a href="#스프링-입문을-위한-자바-향의-원리와-이해" class="header-anchor">#</a> 스프링 입문을 위한 자바 향의 원리와 이해</h1> <h2 id="객체-지향-설계-5원칙-solid"><a href="#객체-지향-설계-5원칙-solid" class="header-anchor">#</a> 객체 지향 설계 5원칙 - SOLID</h2> <p>좋은 소프트웨어 설계를 위해서는 결합도 (coupling) 은 낮추고 응집도 (cohension) 은 높이는 것이 바람직하다.</p> <p>SOLID 의 개념 또한 High Cohension 응집력을 높이고 Loose Coupling 결합도를 낮추는 관점에서 지속적으로 재정립된 것이다.</p> <p><code>결합도</code>는 모듈(클래스)간의 상호 의존정도로써 결합도가 낮으면 모듈간의 <strong>상호 의존성</strong>이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.</p> <p><code>응집도</code>는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 <strong>하나의 책임에 집중</strong>하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 유리하다.</p> <p>SOLID는 객체지향 프로그램을 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍쳐 등 다양한 곳에 적용된다. SOLID 는 눈에 보이는 제품은 아니다 우리가 만드는 제품에 녹여내야 하는 개념이다.</p> <h3 id="srp-single-responsibility-principle"><a href="#srp-single-responsibility-principle" class="header-anchor">#</a> SRP - Single Responsibility Principle</h3> <blockquote><p>어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 한다.</p></blockquote> <p>단일 책임 원칙을 위반하는 사례를 몇가지 보자.</p> <ol><li>한 클래스에 다양한 클래스가 의존하는 경우</li></ol> <p>한 남자의 예로 다음과 같은 의존성이 있다고 가정하면</p> <div class="language- extra-class"><pre><code>어머니 👉 남자 (아들 역할)
직장상사 👉 남자 (사원 역할)
소대장 👉남자 (소대원 역할)
</code></pre></div><p>남자라는 클래스에 너무나도 많은 역할과 책임이 있다. 따라서 이런 경우 역할과 책임을 다음과 같이 분리할 수 있다.</p> <div class="language- extra-class"><pre><code>어머님 👉 아들 (아들 역할)
직장상사 👉 사원 (사원 역할)
소대장 👉 소대원 (소대장)
</code></pre></div><ol start="2"><li>한 속성이 여러 의미를 가지는 경우</li></ol> <p>데이터베이스에서 가령 한 필드에 있어 토지인 경우 면적을, 건물인 경우 층수를 나타내는 테이블이 있다고 가정하자.
이 데이터를 사용할 때마다 if 문을 이용하여 건물인지 토지인지 확인해야 한다.</p> <ol start="3"><li>메서드에서 단일 책임이 지켜지지 않는 경우</li></ol> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> 늑대 <span class="token punctuation">{</span>
	<span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> 수컷 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> 암컷 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token class-name">Boolean</span> 성별<span class="token punctuation">;</span>
	<span class="token keyword">void</span> 일과수행<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>성별 <span class="token operator">==</span> 수컷<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// 먹이를 사냥한다.</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// 새끼들을 돌본다.</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>늑대 클래스에 일과수행 메서드는 성별에 따라 행위가 달라지고 있다. if 문이 존재할 경우 단일 책임 원칙을 위반하는가 의심해볼 필요가 있다.</p> <p>아래와 같이 SRP에 맞게 리팩토링 해보자.</p> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> 늑대 <span class="token punctuation">{</span>
	<span class="token keyword">abstract</span> <span class="token keyword">void</span> 일과수행 <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> 수컷늑대 <span class="token keyword">extends</span> 늑대 <span class="token punctuation">{</span>
	<span class="token keyword">void</span> 일과수행<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 먹이를 사냥한다</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> 암컷늑대 <span class="token keyword">extends</span> 늑대 <span class="token punctuation">{</span>
	<span class="token keyword">void</span> 일과수행<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// 새끼들을 돌본다.</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>어플리케이션의 경계를 정하고 추상화를 통해 클래스를 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자.</p> <h3 id="ocp-open-closed-principle"><a href="#ocp-open-closed-principle" class="header-anchor">#</a> OCP - Open Closed Principle</h3> <blockquote><p>자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.</p></blockquote> <img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5N8pS_BJyueoizDLIXABKijAaxb0gegILLGUjipuVNo9GgUUIMfHMc9oQbA2ed52awXaJ3vLrlN0ELVTszvtRtppVB6DxCdW5KK6C8KlDwyvStK3am5Hd0R-dQycJlZpO89RvhMl9ct529hp0MqGq5Nrmw5QOHW6dAzQPlmkdi6c0SIjLA0EENjr1clkvTmEQJcfG3z2000" alt="uml diagram"> <p>가령 편의점에서 편의점 직원은 근본적으로 판매라는 행위에 있어서 손님이 누가되든 판매자가 누가되든 행위 자체에는 어느 영향도 받지 않는다.</p> <p>따라서 주변의 변화에 손님의 구매 행위에는 영향을 받지 않고 직원은 교대를 통하여 확장에 열려있다.</p> <p>OCP를 따르지 않으면 유연성, 재사용서으 유지보수성에 불리할 수 있다.</p> <h3 id="lsp-liskov-substitution-principle"><a href="#lsp-liskov-substitution-principle" class="header-anchor">#</a> LSP - Liskov Substitution Principle</h3> <blockquote><p>서브 타입은 언제나 자신의 기반 타입 (base type)으로 교체할 수 있어야 한다.</p></blockquote> <blockquote><p>하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.</p></blockquote> <p>객체 지향의 상속은 다음 조건을 만족해야 한다.</p> <ul><li>하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.</li> <li>구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.</li></ul> <p>즉, 객체지향에서 상속은 조직도나 계층도가 아닌 분류도가 되어 한다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>아버지 춘향이 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">딸</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>위의 경우 딸이 아버지를 상속 받아 아버지 - 딸 구조 (조직도, 게층도). 이때 춘향이는 아버지의 행위 (메서드) 를 할 수 있어야 하는데 상당이 어색함이 느껴진다.</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>동물 뽀로로 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">펭귄</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>펭귄이 동물을 상속 받아 동물 - 펭귄 구조 (분류도). 이때 뽀로로는 동물의 역할을 문제 없이 수행할 수 있다.</p> <p>따라서 상속이 잘못되는 경우 LSP를 위반 할 수 있다.</p> <h3 id="isp-interface-segregation-principle"><a href="#isp-interface-segregation-principle" class="header-anchor">#</a> ISP - Interface Segregation Principle</h3> <blockquote><p>클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.</p></blockquote> <p>위의 SRP에서 남자의 역할에 따라 남자 클래스틑 토막내어 하나의 역할과 책임을 가지는 다수의 클래스로 분할 하였다. 하지만 이에 대한 다른 구현으로 ISP가 사용될 수 있다.</p> <p>남자의 역할을 클래스를 분리하여 토막내는것이 아닌 인터페이스를 제한하여 구현하는것도 가능하다. 예를들어 어머니와 관계에서는 아들 인터페이스로 제한하고 직장 상사와의 관계에서는 사원 인터페이스 등등.. 의 형식으로 인터페이스 분할 원칙을 적용할 수 있다.</p> <p>결과적으로 같은 문제를 두고 SRP 와 ISP는 두 가지 해결책이라 볼 수 있다. 이는 프로젝트 요구사항이나 설계자 취향에 따라 선택해서 설계할 수 있지만 가급적 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이다.</p> <p>ISP에서 집고 넘어가야 할 개념중 하나가 바로 <code>인터페이스 최소주의 원칙</code> 이다. 이는 인터페이스를 통해 메서드를 외부에 제공할 때는 <strong>최소한의 메서드만 제공</strong>하라는 원칙이다.</p> <p>상속과 인터페이스에서 상위 클래스는 풍성할수록 좋고 인터페이스는 작을수록 좋다고 했고 LSP에 따라 하위 객체는 상위 객체인 척 할 수 있다. 따라서 인터페이스는 그 역할에 충실한 최소한의 기능만 공개해야 한다.</p> <p>따라서 인터페이스는 ~할 수 있는 (is able to)의 기준으로 만드는 것이 좋다.</p> <h3 id="dip-dependency-inversion-principle"><a href="#dip-dependency-inversion-principle" class="header-anchor">#</a> DIP - Dependency Inversion Principle</h3> <blockquote><p>고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.</p></blockquote> <blockquote><p>추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.</p></blockquote> <p>예를들어 자동차와 스노우 타이어 사이의 관계를 살펴보자.</p> <img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKhEIImkLb1wCs_2w_wPRpQiK598B5P8JYo2ItGjUTswuysi3M-R6zxCtV9csXQmYk8IBYwWAWLTNJiGso4rBmLe6W00" alt="uml diagram"> <p>자동차는 스노우 타이어에 의존한다. 하지만 스노우 타이어는 계절이 변함에 따라 지속적으로 교체 되어야한다. 즉, 스노우타이어가 일반 타이어로 교체 될때마다 자동차는 그 영향에 노출되어 있다.</p> <p>이에 의존 역전 원칙 DIP를 적용해보자.</p> <img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKhEIImkLb1wCs_2w_wPRpQiK598B5P8JYpYoimhIIrAIqnELL1wszpmPkwMDzEsW2KpuNgwbhnktV5crWPK-H93k8AvUrvlc84cQmIJVRLbujl-jMYonbn0knLqTUs0rcGgsEZfWOo3CenW36CkXzIy5A3h0G00" alt="uml diagram"> <p>위와 같이 DIP 리팩토링을 통하여 더 이상 자동차는 타이어 변화에 영향을 받지 않는다.</p> <p>이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.</p> <h3 id="solid-summary"><a href="#solid-summary" class="header-anchor">#</a> SOLID - Summary</h3> <ul><li>SRP : 어떤 클래스를 변경하는 이유는 하나뿐</li> <li>OCP : 자신의 확장에는 열려 있고, 주변의 변화에는 닫혀있다.</li> <li>LSP : 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.</li> <li>ISP : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.</li> <li>DIP : 자신보다 변하기 쉬운껏에 의존하지 마라.</li></ul> <h2 id="스프링이-사랑한-디자인-패턴"><a href="#스프링이-사랑한-디자인-패턴" class="header-anchor">#</a> 스프링이 사랑한 디자인 패턴</h2> <p>객체지향 4대원칙, 설계 원칙(SOLID), 디자인 패턴을 요리에 비유해보자.</p> <table><thead><tr><th style="text-align:center;">요리</th> <th style="text-align:center;">OOP</th></tr></thead> <tbody><tr><td style="text-align:center;">요리도구</td> <td style="text-align:center;">4대 원칙</td></tr> <tr><td style="text-align:center;">요리도구 사용법</td> <td style="text-align:center;">설계 원칙</td></tr> <tr><td style="text-align:center;">레시피</td> <td style="text-align:center;">디자인 패턴</td></tr></tbody></table> <h3 id="adapter-pattern"><a href="#adapter-pattern" class="header-anchor">#</a> Adapter Pattern</h3> <p>어댑터 패턴은 변환기라고 할 수 있다. 즉, 두 인터페이스 사이에 통신이 가능하게 해준다.</p> <h3 id="singleton-pattern"><a href="#singleton-pattern" class="header-anchor">#</a> Singleton Pattern</h3> <p>싱글턴 패턴이란 인스턴스를 하나만 만들어 사용하기 위한 패턴이다. 커넥션 풀, 스레드 풀, 디바이스 설정 등과 같은 경우 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게 되고 프로그램이 예상치 못한 결과를 낳을 수 있지만, 싱글턴 패턴은 오직 인스턴스를 하나만 만들고 이를 재사용한다.</p> <p>JS Code</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> singletonObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> singletonInstance<span class="token punctuation">;</span>
	<span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//some codes</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//other codes</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token punctuation">{</span>
			func1<span class="token operator">:</span> f1<span class="token punctuation">,</span>
			func2<span class="token operator">:</span> f2
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token punctuation">{</span>
		<span class="token function-variable function">getInstance</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>singletonInstance<span class="token punctuation">)</span><span class="token punctuation">{</span>
				singletonInstance <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> singletonInstance<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">function</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>singletonInstance<span class="token punctuation">)</span><span class="token punctuation">{</span>
			singletonInstance <span class="token operator">=</span> <span class="token function">intialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>위와 같이 클라이언트에서 create 메서드에는 접근하지 못하게 private으로 getInstance 메서드는 public 으로 구현하여</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> singletonObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>다음과 같이 인스턴스를 생성할 수 있다. 싱글톤은 race condition에 영향을 받기 쉽기 때문에 동기화에 신경써야 한다.</p> <p>JAVA Code</p> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>
	<span class="token keyword">static</span> <span class="token class-name">Singleton</span> singletonObject<span class="token punctuation">;</span> <span class="token comment">// 정적 참조 변수</span>

	<span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// private 생성자</span>

	<span class="token comment">// 객체 반환 정적 메서드</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			singletonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>만약 클라이언트 측에서</p> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Error 🤯</span>
<span class="token comment">// private 생성자이므로 new를 통해 인스턴스를 생성할 수 없다.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>정리하면 싱글턴 패턴은 다음과 같은 특징을 가진다.</p> <ul><li>private 생성자를 갖는다.</li> <li>단일 객체 참조 변수를 정적 속성으로 갖는다.</li> <li>단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다.</li> <li>단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다.</li></ul> <h3 id="팩터리-메서드-패턴-factory-method-pattern"><a href="#팩터리-메서드-패턴-factory-method-pattern" class="header-anchor">#</a> 팩터리 메서드 패턴 (Factory Method Pattern)</h3> <p>팩터리 메서드는 객체를 생성 반환하는 메서드를 말한다.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JeongShin_Blog/algorithms/Problems/Programmers-l4.html" class="prev">
        프로그래머스 Level04
      </a></span> <span class="next"><a href="/JeongShin_Blog/book-review/You_Don't_Know_JS/">
        You Don't Know JS
      </a>
      →
    </span></p></div>  <div><div id="comment"></div></div></main> <footer class="siteFooter">
  COPYRIGHT©2020 ALL RIGHT JeongShin
  <br>sjeong1127@gmail.com . +82-10-2169-2142 .
  <br> <a href="https://www.instagram.com/jeongshin96/" target="_blank">Instagram</a> <a href="https://github.com/JeongShin" target="_blank">GitHub</a></footer></div><div class="global-ui"></div></div>
    <script src="/JeongShin_Blog/assets/js/app.c07b8bc6.js" defer></script><script src="/JeongShin_Blog/assets/js/2.0c6a2499.js" defer></script><script src="/JeongShin_Blog/assets/js/25.b3825ed9.js" defer></script>
  </body>
</html>
