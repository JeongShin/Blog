(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{384:function(t,r,a){"use strict";a.r(r);var s=a(42),e=Object(s.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"이론-정리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#이론-정리"}},[t._v("#")]),t._v(" 이론 정리")]),t._v(" "),a("h2",{attrs:{id:"그래프-알고리즘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#그래프-알고리즘"}},[t._v("#")]),t._v(" 그래프 알고리즘")]),t._v(" "),a("ul",[a("li",[t._v("Shortest Path Algorithms")])]),t._v(" "),a("ol",[a("li",[a("p",[a("code",[t._v("Dijkstra's Algorithm")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Floyd - Warshall Algorithm")])])])]),t._v(" "),a("p",[t._v("👉 모든 쌍의 최단 경로 알고리즘")]),t._v(" "),a("p",[t._v("일반적으로 Dijskstra's 알고리즘을 통하여 모든 pair들의 최단 경로를 구하게 되면 시간복잡도가 O(N ^ 2) * N = O(N ^ 3)이 된다. 하지만 Floyd - Warshall 알고리즘은 다이나믹 프로그래밍 기법을 이용하여 시간복잡도는 O(N ^ 3) 이지만 좀 더 빠르게 solution을 구할 수 있다.")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("code",[t._v("Bellman-Ford Algorithm")])])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[a("code",[t._v("SPFA")])])]),t._v(" "),a("h2",{attrs:{id:"dynamic-programming-vs-greedy-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-programming-vs-greedy-method"}},[t._v("#")]),t._v(" Dynamic Programming vs Greedy Method")]),t._v(" "),a("p",[t._v("문제를 접근할 때 그리디 기법을 사용할 지 dynamic programming 을 사용할 지 선택하는 기준은 다음과 같다.")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("그리디")]),t._v(" 👉 항상 최적의 해를 구한다.\n예를들어 MST 문제에서 Kruskal 알고리즘은 항상 최소 가중치 edge만 선택하여 확장해 나가기 때문에 "),a("strong",[t._v("항상 Optimal")]),t._v(" 한 한개의 해만 구한다.")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("code",[t._v("다이나믹 프로그래밍")]),t._v(" 👉 모든 해를 구한뒤 최적의 해를 선택한다.\n대부분의 경우 모든 가능한 해 (feasible solution) 를 고려해야 하기 때문의 시간이 그리디에 비해 오래 걸린다.")]),t._v(" "),a("p",[t._v("Principle of Optimality")])])])])}),[],!1,null,null,null);r.default=e.exports}}]);