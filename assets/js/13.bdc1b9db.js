(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{406:function(t,r,s){"use strict";s.r(r);var a=s(67),l=Object(a.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"이론-정리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#이론-정리"}},[t._v("#")]),t._v(" 이론 정리")]),t._v(" "),s("h2",{attrs:{id:"그래프-알고리즘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#그래프-알고리즘"}},[t._v("#")]),t._v(" 그래프 알고리즘")]),t._v(" "),s("ul",[s("li",[t._v("Shortest Path Algorithms")])]),t._v(" "),s("ol",[s("li",[s("p",[s("code",[t._v("Dijkstra's Algorithm")]),t._v("\n👉")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Floyd - Warshall Algorithm")])])])]),t._v(" "),s("p",[t._v("👉 모든 쌍의 최단 경로 알고리즘")]),t._v(" "),s("p",[t._v("일반적으로 Dijskstra's 알고리즘을 통하여 모든 pair들의 최단 경로를 구하게 되면 시간복잡도가 O(N ^ 2) * N = O(N ^ 3)이 된다. 하지만 Floyd - Warshall 알고리즘은 다이나믹 프로그래밍 기법을 이용하여 시간복잡도는 O(N ^ 3) 이지만 좀 더 빠르게 solution을 구할 수 있다.")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("code",[t._v("Bellman-Ford Algorithm")])])]),t._v(" "),s("p",[t._v("👉음의 가중치 최단 경로 알고리즘")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("code",[t._v("SPFA")])])])])}),[],!1,null,null,null);r.default=l.exports}}]);